import { BlobId } from "./bcs.mjs";
import { fromBase64, toBase64 } from "@mysten/bcs";

//#region src/utils/index.ts
const DIGEST_LEN = 32;
const BLOB_ID_LEN = 32;
const REQUIRED_ALIGNMENT_BY_ENCODING_TYPE = {
	RS2: 2,
	RedStuff: 2
};
const MAX_SYMBOL_SIZE_BY_ENCODING_TYPE = {
	RS2: 2 ** 16 - 1,
	RedStuff: 2 ** 16 - 1
};
function encodedBlobLength(unencodedLength, nShards, encodingType = "RS2") {
	const sliverSize = encodedSliverSize(unencodedLength, nShards, encodingType);
	return nShards * (nShards * DIGEST_LEN * 2 + BLOB_ID_LEN) + sliverSize;
}
function encodedSliverSize(unencodedLength, nShards, encodingType = "RS2") {
	const { primarySymbols, secondarySymbols } = getSourceSymbols(nShards, encodingType);
	let symbolSize = Math.floor((Math.max(unencodedLength, 1) - 1) / (primarySymbols * secondarySymbols)) + 1;
	if (encodingType === "RS2" && symbolSize % 2 === 1) symbolSize = symbolSize + 1;
	return (primarySymbols + secondarySymbols) * symbolSize * nShards;
}
function getSourceSymbols(nShards, encodingType = "RS2") {
	const safetyLimit = decodingSafetyLimit(nShards, encodingType);
	const maxFaulty = getMaxFaultyNodes(nShards);
	const minCorrect = nShards - maxFaulty;
	return {
		primarySymbols: minCorrect - maxFaulty - safetyLimit,
		secondarySymbols: minCorrect - safetyLimit
	};
}
function isQuorum(size, nShards) {
	return size > 2 * getMaxFaultyNodes(nShards);
}
function isAboveValidity(size, nShards) {
	return size > getMaxFaultyNodes(nShards);
}
function getMaxFaultyNodes(nShards) {
	return Math.floor((nShards - 1) / 3);
}
function decodingSafetyLimit(nShards, encodingType) {
	switch (encodingType) {
		case "RedStuff": return Math.min(5, Math.floor(getMaxFaultyNodes(nShards) / 5));
		case "RS2": return 0;
		default: throw new Error(`Encountered unknown encoding type of ${encodingType}`);
	}
}
const BYTES_PER_UNIT_SIZE = 1024 * 1024;
function storageUnitsFromSize(size) {
	return Math.ceil(size / BYTES_PER_UNIT_SIZE);
}
function rotationOffset(bytes, modulus) {
	return bytes.reduce((acc, byte) => (acc * 256 + byte) % modulus, 0);
}
function toShardIndex(sliverPairIndex, blobId, numShards) {
	return (sliverPairIndex + rotationOffset(BlobId.serialize(blobId).toBytes(), numShards)) % numShards;
}
function sliverPairIndexFromSecondarySliverIndex(sliverIndex, numShards) {
	return numShards - sliverIndex - 1;
}
function toPairIndex(shardIndex, blobId, numShards) {
	const offset = rotationOffset(BlobId.serialize(blobId).toBytes(), numShards);
	return (numShards + shardIndex - offset) % numShards;
}
function signersToBitmap(signers, committeeSize) {
	const bitmapSize = Math.ceil(committeeSize / 8);
	const bitmap = new Uint8Array(bitmapSize);
	for (const signer of signers) {
		const byteIndex = Math.floor(signer / 8);
		const bitIndex = signer % 8;
		bitmap[byteIndex] |= 1 << bitIndex;
	}
	return bitmap;
}
function getShardIndicesByNodeId(committee) {
	const shardIndicesByNodeId = /* @__PURE__ */ new Map();
	for (const node of committee[0].contents) {
		if (!shardIndicesByNodeId.has(node.key)) shardIndicesByNodeId.set(node.key, []);
		shardIndicesByNodeId.get(node.key).push(...node.value);
	}
	return shardIndicesByNodeId;
}
function urlSafeBase64(bytes) {
	return toBase64(bytes).replace(/=*$/, "").replaceAll("+", "-").replaceAll("/", "_");
}
function fromUrlSafeBase64(base64) {
	return fromBase64(base64.replaceAll("-", "+").replaceAll("_", "/"));
}
function getSizes(blobSize, numShards) {
	const encodedBlobSize = encodedSliverSize(blobSize, numShards);
	const { primarySymbols, secondarySymbols } = getSourceSymbols(numShards);
	const totalSymbols = (primarySymbols + secondarySymbols) * numShards;
	if (encodedBlobSize % totalSymbols !== 0) throw new Error("encoded blob size should be divisible by total symbols");
	const symbolSize = encodedBlobSize / totalSymbols;
	if (encodedBlobSize % totalSymbols !== 0) throw new Error("blob length should be divisible by total symbols");
	return {
		symbolSize,
		rowSize: symbolSize * secondarySymbols,
		columnSize: symbolSize * primarySymbols,
		blobSize
	};
}

//#endregion
export { MAX_SYMBOL_SIZE_BY_ENCODING_TYPE, REQUIRED_ALIGNMENT_BY_ENCODING_TYPE, encodedBlobLength, fromUrlSafeBase64, getShardIndicesByNodeId, getSizes, getSourceSymbols, isAboveValidity, isQuorum, signersToBitmap, sliverPairIndexFromSecondarySliverIndex, storageUnitsFromSize, toPairIndex, toShardIndex, urlSafeBase64 };
//# sourceMappingURL=index.mjs.map