import { BlobMetadata, BlobMetadataWithId, SliverData } from "../utils/bcs.mjs";
import { ConnectionTimeoutError, StorageNodeAPIError, StorageNodeError, UserAbortError } from "./error.mjs";
import { mergeHeaders } from "./utils.mjs";

//#region src/storage-node/client.ts
var StorageNodeClient = class {
	#fetch;
	#timeout;
	#onError;
	constructor({ fetch: overriddenFetch, timeout, onError } = {}) {
		this.#fetch = overriddenFetch ?? globalThis.fetch;
		this.#timeout = timeout ?? 3e4;
		this.#onError = onError;
	}
	/**
	* Gets the metadata associated with a Walrus blob.
	*/
	async getBlobMetadata({ blobId }, options) {
		const bcsBytes = await (await this.#request(`/v1/blobs/${blobId}/metadata`, {
			...options,
			headers: mergeHeaders({ Accept: "application/octet-stream" }, options.headers)
		})).arrayBuffer();
		return BlobMetadataWithId.parse(new Uint8Array(bcsBytes));
	}
	/**
	* Gets the status associated with a Walrus blob.
	*/
	async getBlobStatus({ blobId }, options) {
		const blobStatus = (await (await this.#request(`/v1/blobs/${blobId}/status`, options)).json()).success.data;
		if (blobStatus === "nonexistent") return { type: "nonexistent" };
		if ("invalid" in blobStatus) return {
			type: "invalid",
			...blobStatus.invalid
		};
		if ("permanent" in blobStatus) return {
			type: "permanent",
			...blobStatus.permanent
		};
		if ("deletable" in blobStatus) return {
			type: "deletable",
			...blobStatus.deletable
		};
		throw new StorageNodeError(`Unknown blob status received: ${blobStatus}`);
	}
	/**
	* Stores the metadata associated with a registered Walrus blob at this storage
	* node. This is a pre-requisite for storing the encoded slivers of the blob. The
	* ID of the blob must first be registered on Sui, after which storing the metadata
	* becomes possible.
	*
	* This endpoint may return an error if the node has not yet received the
	* registration event from the chain.
	*/
	async storeBlobMetadata({ blobId, metadata }, options) {
		const body = typeof metadata === "object" && "V1" in metadata ? BlobMetadata.serialize(metadata).toBytes() : metadata;
		return await (await this.#request(`/v1/blobs/${blobId}/metadata`, {
			...options,
			method: "PUT",
			body,
			headers: mergeHeaders({ "Content-Type": "application/octet-stream" }, options.headers)
		})).json();
	}
	/**
	* Gets the primary or secondary sliver identified by the specified blob ID and
	* index. The index should represent a sliver that is assigned to be stored at one
	* of the shards managed by this storage node during this epoch.
	*/
	async getSliver({ blobId, sliverPairIndex, sliverType }, options) {
		const bcsBytes = await (await this.#request(`/v1/blobs/${blobId}/slivers/${sliverPairIndex}/${sliverType}`, {
			...options,
			headers: mergeHeaders({ Accept: "application/octet-stream" }, options.headers)
		})).arrayBuffer();
		return new Uint8Array(bcsBytes);
	}
	/**
	* Stores a primary or secondary blob sliver at the storage node.
	*/
	async storeSliver({ blobId, sliverPairIndex, sliverType, sliver }, options) {
		const body = typeof sliver === "object" && "symbols" in sliver ? SliverData.serialize(sliver).toBytes() : sliver;
		return await (await this.#request(`/v1/blobs/${blobId}/slivers/${sliverPairIndex}/${sliverType}`, {
			...options,
			method: "PUT",
			body,
			headers: mergeHeaders({ "Content-Type": "application/octet-stream" }, options.headers)
		})).json();
	}
	/**
	* Gets a signed storage confirmation from this storage node, indicating that all shards
	* assigned to this storage node for the current epoch have stored their respective slivers.
	*/
	async getDeletableBlobConfirmation({ blobId, objectId }, options) {
		return await (await this.#request(`/v1/blobs/${blobId}/confirmation/deletable/${objectId}`, options)).json();
	}
	/**
	* Gets a signed storage confirmation from this storage node, indicating that all shards
	* assigned to this storage node for the current epoch have stored their respective slivers.
	*/
	async getPermanentBlobConfirmation({ blobId }, options) {
		return await (await this.#request(`/v1/blobs/${blobId}/confirmation/permanent`, options)).json();
	}
	async #request(path, options) {
		const { nodeUrl, signal, timeout, ...init } = options;
		if (signal?.aborted) throw new UserAbortError();
		const timeoutSignal = AbortSignal.timeout(timeout ?? this.#timeout);
		let response;
		try {
			const fetch = this.#fetch;
			response = await fetch(`${nodeUrl}${path}`, {
				...init,
				signal: signal ? AbortSignal.any([timeoutSignal, signal]) : timeoutSignal
			});
		} catch (error) {
			if (signal?.aborted) throw new UserAbortError();
			if (error instanceof Error && error.name === "AbortError") {
				const error$1 = new ConnectionTimeoutError();
				this.#onError?.(error$1);
				throw error$1;
			}
			this.#onError?.(error);
			throw error;
		}
		if (!response.ok) {
			const errorText = await response.text().catch((reason) => reason);
			const errorJSON = safeParseJSON(errorText);
			const errorMessage = errorJSON ? void 0 : errorText;
			const error = StorageNodeAPIError.generate(response.status, errorJSON, errorMessage);
			this.#onError?.(error);
			throw error;
		}
		return response;
	}
};
function safeParseJSON(value) {
	try {
		return JSON.parse(value);
	} catch {
		return;
	}
}

//#endregion
export { StorageNodeClient };
//# sourceMappingURL=client.mjs.map