//#region src/storage-node/error.ts
var StorageNodeError = class extends Error {};
var StorageNodeAPIError = class StorageNodeAPIError extends StorageNodeError {
	constructor(status, error, message) {
		super(StorageNodeAPIError.#makeMessage(status, error, message));
		this.status = status;
		this.error = error;
	}
	static #makeMessage(status, error, message) {
		function hasErrorMessage(error$1) {
			return typeof error$1?.error?.message === "string";
		}
		const inferredMessage = hasErrorMessage(error) ? error.error.message : message;
		const finalMessage = inferredMessage ? inferredMessage : JSON.stringify(error);
		if (status && finalMessage) return `${status} ${finalMessage}`;
		else if (finalMessage) return finalMessage;
		else if (status) return `${status} status code (no body)`;
		return "(no status code or body)";
	}
	static generate(status, errorResponse, message) {
		if (!status) return new ConnectionError({ message });
		if (status === 400) return BadRequestError.generate(status, errorResponse, message);
		if (status === 401) return new AuthenticationError(status, errorResponse, message);
		if (status === 403) return new PermissionDeniedError(status, errorResponse, message);
		if (status === 404) return new NotFoundError(status, errorResponse, message);
		if (status === 409) return new ConflictError(status, errorResponse, message);
		if (status === 422) return new UnprocessableEntityError(status, errorResponse, message);
		if (status === 429) return new RateLimitError(status, errorResponse, message);
		if (status === 451) return new LegallyUnavailableError(status, errorResponse, message);
		if (status >= 500) return new InternalServerError(status, errorResponse, message);
		return new StorageNodeAPIError(status, errorResponse, message);
	}
};
var UserAbortError = class extends StorageNodeAPIError {
	constructor({ message } = {}) {
		super(void 0, void 0, message || "Request was aborted.");
	}
};
var ConnectionError = class extends StorageNodeAPIError {
	constructor({ message }) {
		super(void 0, void 0, message || "Connection error.");
	}
};
var ConnectionTimeoutError = class extends StorageNodeAPIError {
	constructor({ message } = {}) {
		super(void 0, void 0, message ?? "Request timed out.");
	}
};
var BadRequestError = class BadRequestError extends StorageNodeAPIError {
	static generate(status, errorResponse, message) {
		if (errorResponse && typeof errorResponse === "object" && "error" in errorResponse) {
			if (errorResponse.error.details?.[0]?.reason === "NOT_REGISTERED") return new BlobNotRegisteredError(errorResponse, message);
		}
		return new BadRequestError(status, errorResponse, message);
	}
};
var BlobNotRegisteredError = class extends StorageNodeAPIError {
	constructor(error, message) {
		super(400, error, message);
	}
};
var AuthenticationError = class extends StorageNodeAPIError {};
var PermissionDeniedError = class extends StorageNodeAPIError {};
var NotFoundError = class extends StorageNodeAPIError {};
var ConflictError = class extends StorageNodeAPIError {};
var UnprocessableEntityError = class extends StorageNodeAPIError {};
var RateLimitError = class extends StorageNodeAPIError {};
var LegallyUnavailableError = class extends StorageNodeAPIError {};
var InternalServerError = class extends StorageNodeAPIError {};

//#endregion
export { AuthenticationError, BadRequestError, BlobNotRegisteredError, ConflictError, ConnectionError, ConnectionTimeoutError, InternalServerError, LegallyUnavailableError, NotFoundError, PermissionDeniedError, RateLimitError, StorageNodeAPIError, StorageNodeError, UnprocessableEntityError, UserAbortError };
//# sourceMappingURL=error.mjs.map