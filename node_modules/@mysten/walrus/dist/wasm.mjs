import { BlobId, blobIdFromBytes } from "./utils/bcs.mjs";
import { getSourceSymbols } from "./utils/index.mjs";
import { fromBase64 } from "@mysten/bcs";
import init, { BlobEncoder, bls12381_min_pk_aggregate, bls12381_min_pk_verify } from "@mysten/walrus-wasm";

//#region src/wasm.ts
async function getWasmBindings(url) {
	await init({ module_or_path: url });
	function encodeBlob(nShards, bytes, encodingType = "RS2") {
		const encoder = new BlobEncoder(nShards);
		if (encodingType !== "RS2") throw new Error(`Unsupported encoding type: ${encodingType}`);
		const bufferSizes = computeBcsBufferSizes(bytes.length, nShards);
		const primaryBuffers = Array.from({ length: nShards }).map(() => new Uint8Array(bufferSizes.primary));
		const secondaryBuffers = Array.from({ length: nShards }).map(() => new Uint8Array(bufferSizes.secondary));
		const [metadata, rootHash] = encoder.encode(bytes, primaryBuffers, secondaryBuffers);
		return {
			primarySlivers: primaryBuffers,
			secondarySlivers: secondaryBuffers,
			blobId: blobIdFromBytes(new Uint8Array(metadata.blob_id)),
			metadata: metadata.metadata,
			rootHash: new Uint8Array(rootHash.Digest)
		};
	}
	function combineSignatures(confirmations, signerIndices) {
		const signature = bls12381_min_pk_aggregate(confirmations.map((confirmation) => fromBase64(confirmation.signature)));
		return {
			signers: signerIndices,
			serializedMessage: fromBase64(confirmations[0].serializedMessage),
			signature
		};
	}
	function decodePrimarySlivers(blobId, nShards, size, slivers, encodingType = "RS2") {
		const encoder = new BlobEncoder(nShards);
		if (encodingType !== "RS2") throw new Error(`Unsupported encoding type: ${encodingType}`);
		const blobSize = BigInt(size);
		const outputBuffer = new Uint8Array(Number(blobSize));
		encoder.decode(BlobId.serialize(blobId).toBytes(), blobSize, slivers, outputBuffer);
		return outputBuffer;
	}
	function getVerifySignature() {
		return (confirmation, publicKey) => bls12381_min_pk_verify(fromBase64(confirmation.signature), publicKey, fromBase64(confirmation.serializedMessage));
	}
	function computeMetadata(nShards, bytes, encodingType = "RS2") {
		const [blobId, rootHash, unencodedLength, encType] = new BlobEncoder(nShards).compute_metadata(bytes);
		if (encodingType !== "RS2") throw new Error(`Unsupported encoding type: ${encodingType}`);
		return {
			blobId: blobIdFromBytes(new Uint8Array(blobId)),
			rootHash: new Uint8Array(rootHash.Digest),
			unencodedLength: BigInt(unencodedLength),
			encodingType: encType
		};
	}
	return {
		encodeBlob,
		combineSignatures,
		decodePrimarySlivers,
		getVerifySignature,
		computeMetadata
	};
}
function uleb128Size(value) {
	let size = 1;
	value >>= 7;
	while (value !== 0) {
		size++;
		value >>= 7;
	}
	return size;
}
function computeBcsBufferSize(dataLength) {
	return uleb128Size(dataLength) + dataLength + 2 + 2;
}
function computeBcsBufferSizes(blobSize, nShards) {
	const { primarySymbols, secondarySymbols } = getSourceSymbols(nShards);
	let symbolSize = Math.floor((Math.max(blobSize, 1) - 1) / (primarySymbols * secondarySymbols)) + 1;
	if (symbolSize % 2 === 1) symbolSize = symbolSize + 1;
	const primarySliverSize = secondarySymbols * symbolSize;
	const secondarySliverSize = primarySymbols * symbolSize;
	return {
		nShards,
		primary: computeBcsBufferSize(primarySliverSize),
		secondary: computeBcsBufferSize(secondarySliverSize)
	};
}

//#endregion
export { getWasmBindings };
//# sourceMappingURL=wasm.mjs.map