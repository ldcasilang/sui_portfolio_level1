import { BlobMetadata } from "./utils/bcs.mjs";
import { StorageConfirmation, StoreBlobMetadataRequestInput, StoreSliverRequestInput, Uploadable } from "./storage-node/types.mjs";
import { Blob } from "./contracts/walrus/blob.mjs";
import { StorageNodeInfo } from "./contracts/walrus/storage_node.mjs";
import { RequestOptions, StorageNodeClientOptions } from "./storage-node/client.mjs";
import { UploadRelayClientOptions } from "./upload-relay/client.mjs";
import { WalrusFile } from "./files/file.mjs";
import { Transaction, TransactionObjectArgument } from "@mysten/sui/transactions";
import { ClientWithCoreApi } from "@mysten/sui/client";
import { Signer } from "@mysten/sui/cryptography";

//#region src/types.d.ts

/**
 * Configuration for the Walrus package on sui
 *
 * This is used to configure the Walrus package to use a specific package ID, system object ID, staking pool ID, and WAL package ID.
 */
interface WalrusPackageConfig {
  /** The system object ID of the Walrus package */
  systemObjectId: string;
  /** The staking pool ID of the Walrus package */
  stakingPoolId: string;
  exchangeIds?: string[];
}
type WalrusNetworkOrPackageConfig = {
  network: 'mainnet' | 'testnet';
  packageConfig?: WalrusPackageConfig;
} | {
  network?: never;
  packageConfig: WalrusPackageConfig;
};
type TipStrategy = {
  const: number | bigint;
} | {
  linear: {
    base: number | bigint;
    perEncodedKib: number | bigint;
  };
};
type UploadRelayTipConfig = {
  address: string;
  max?: number;
  kind: TipStrategy;
};
interface UploadRelayConfig extends UploadRelayClientOptions {
  sendTip?: null | UploadRelayTipConfig | {
    max: number;
  };
}
interface BaseWalrusClientConfig {
  storageNodeClientOptions?: StorageNodeClientOptions;
  wasmUrl?: string;
  uploadRelay?: UploadRelayConfig;
}
/**
 * Configuration for the Walrus client.
 *
 * This is used to configure the Walrus client to use a specific storage node client options, network, and Sui client or RPC URL.
 */
type WalrusClientConfig = BaseWalrusClientConfig & WalrusNetworkOrPackageConfig & {
  suiClient: ClientWithCoreApi;
};
type WalrusOptions<Name = 'walrus'> = BaseWalrusClientConfig & {
  packageConfig?: WalrusPackageConfig;
  name?: Name;
};
type WalrusClientExtensionOptions = BaseWalrusClientConfig & {
  packageConfig?: WalrusPackageConfig;
};
type WalrusClientRequestOptions = Pick<RequestOptions, 'signal'>;
interface StorageNode {
  networkUrl: string;
  info: (typeof StorageNodeInfo)['$inferType'];
  shardIndices: number[];
  nodeIndex: number;
  id: string;
}
interface CommitteeInfo {
  byShardIndex: Map<number, StorageNode>;
  nodes: StorageNode[];
}
interface StorageWithSizeOptions {
  /** The encoded size of the blob. */
  size: number;
  /** The number of epoch the storage will be reserved for. */
  epochs: number;
  /** optionally specify a WAL coin pay for the registration.  This will consume WAL from the signer by default. */
  walCoin?: TransactionObjectArgument;
}
interface RegisterBlobOptions extends StorageWithSizeOptions {
  blobId: string;
  rootHash: Uint8Array;
  deletable: boolean;
  /** optionally specify a WAL coin pay for the registration.  This will consume WAL from the signer by default. */
  walCoin?: TransactionObjectArgument;
  /** The attributes to write for the blob. */
  attributes?: Record<string, string | null>;
}
type CertifyBlobOptions = {
  blobId: string;
  blobObjectId: string;
  deletable: boolean;
} & ({
  /** An array of confirmations.
   * These confirmations must be provided in the same order as the nodes in the committee.
   * For nodes that have not provided a confirmation you can pass `null` */
  confirmations: (StorageConfirmation | null)[];
  certificate?: never;
} | {
  certificate: ProtocolMessageCertificate;
  confirmations?: never;
});
type DeletableConfirmationOptions = {
  deletable: false;
  objectId?: string;
} | {
  deletable: true;
  objectId: string;
};
type GetStorageConfirmationOptions = {
  blobId: string;
  nodeIndex: number;
} & DeletableConfirmationOptions & WalrusClientRequestOptions;
type ReadBlobOptions = {
  blobId: string;
} & WalrusClientRequestOptions;
type GetCertificationEpochOptions = ReadBlobOptions;
type GetBlobMetadataOptions = ReadBlobOptions;
type GetSliversOptions = ReadBlobOptions;
interface GetSecondarySliverOptions extends WalrusClientRequestOptions {
  blobId: string;
  index: number;
}
type GetVerifiedBlobStatusOptions = ReadBlobOptions;
type ComputeBlobMetadataOptions = {
  bytes: Uint8Array;
  numShards?: number;
};
interface SliversForNode {
  primary: {
    sliverIndex: number;
    sliverPairIndex: number;
    shardIndex: number;
    sliver: Uint8Array;
  }[];
  secondary: {
    sliverIndex: number;
    sliverPairIndex: number;
    shardIndex: number;
    sliver: Uint8Array;
  }[];
}
type WriteSliversToNodeOptions = {
  blobId: string;
  nodeIndex: number;
  slivers: SliversForNode;
} & WalrusClientRequestOptions;
type WriteSliverOptions = StoreSliverRequestInput & WalrusClientRequestOptions;
type WriteMetadataOptions = {
  nodeIndex: number;
  metadata: Uploadable | typeof BlobMetadata.$inferInput;
} & StoreBlobMetadataRequestInput & WalrusClientRequestOptions;
type WriteEncodedBlobOptions = {
  blobId: string;
  nodeIndex: number;
  metadata: Uploadable | typeof BlobMetadata.$inferInput;
  slivers: SliversForNode;
} & DeletableConfirmationOptions & WalrusClientRequestOptions;
type WriteEncodedBlobToNodesOptions = {
  blobId: string;
  metadata: Uploadable | typeof BlobMetadata.$inferInput;
  sliversByNode: SliversForNode[];
} & DeletableConfirmationOptions & WalrusClientRequestOptions;
type WriteBlobToUploadRelayOptions = {
  blobId: string;
  blob: Uint8Array;
  nonce: Uint8Array;
  txDigest: string;
  blobObjectId: string;
  deletable: boolean;
  encodingType?: EncodingType;
} & WalrusClientRequestOptions;
type WriteBlobOptions = {
  blob: Uint8Array;
  deletable: boolean;
  /** The number of epochs the blob should be stored for. */
  epochs: number;
  signer: Signer;
  /** Where the blob should be transferred to after it is registered.  Defaults to the signer address. */
  owner?: string;
  /** The attributes to write for the blob. */
  attributes?: Record<string, string | null>;
} & WalrusClientRequestOptions;
interface WriteQuiltOptions extends Omit<WriteBlobOptions, 'blob'> {
  blobs: {
    contents: Uint8Array;
    identifier: string;
    tags?: Record<string, string>;
  }[];
}
interface WriteFilesOptions extends Omit<WriteBlobOptions, 'blob'> {
  files: WalrusFile[];
}
interface WriteFilesFlowOptions {
  files: WalrusFile[];
}
interface WriteFilesFlowRegisterOptions extends Omit<WriteBlobOptions, 'blob' | 'signer'> {
  owner: string;
}
interface WriteFilesFlowUploadOptions {
  digest: string;
}
interface WriteFilesFlow {
  encode: () => Promise<void>;
  register: (options: WriteFilesFlowRegisterOptions) => Transaction;
  upload: (options: WriteFilesFlowUploadOptions) => Promise<void>;
  certify: () => Transaction;
  listFiles: () => Promise<{
    id: string;
    blobId: string;
    blobObject: (typeof Blob)['$inferType'];
  }[]>;
}
interface WriteBlobFlowOptions {
  blob: Uint8Array;
}
interface WriteBlobFlowRegisterOptions extends Omit<WriteBlobOptions, 'blob' | 'signer'> {
  owner: string;
}
interface WriteBlobFlowUploadOptions {
  digest: string;
}
interface WriteBlobFlow {
  encode: () => Promise<void>;
  register: (options: WriteBlobFlowRegisterOptions) => Transaction;
  upload: (options: WriteBlobFlowUploadOptions) => Promise<void>;
  certify: () => Transaction;
  getBlob: () => Promise<{
    blobId: string;
    blobObject: (typeof Blob)['$inferType'];
  }>;
}
interface DeleteBlobOptions {
  blobObjectId: string;
}
type ExtendBlobOptions = {
  blobObjectId: string;
  /** optionally specify a WAL coin pay for the registration.  This will consume WAL from the signer by default. */
  walCoin?: TransactionObjectArgument;
} & ({
  /** The number of epochs the blob should be stored for. */
  epochs: number;
  endEpoch?: never;
} | {
  /** The new end epoch for the storage period of the blob. */
  endEpoch: number;
  epochs?: never;
});
type WriteBlobAttributesOptions = {
  attributes: Record<string, string | null>;
} & ({
  blobObject: TransactionObjectArgument;
  blobObjectId?: never;
} | {
  blobObjectId: string;
  blobObject?: never;
});
type EncodingType = Extract<typeof EncodingType.$inferInput, string>;
interface ProtocolMessageCertificate {
  signers: number[];
  serializedMessage: Uint8Array;
  signature: Uint8Array;
}
//#endregion
export { CertifyBlobOptions, CommitteeInfo, ComputeBlobMetadataOptions, DeletableConfirmationOptions, DeleteBlobOptions, EncodingType, ExtendBlobOptions, GetBlobMetadataOptions, GetCertificationEpochOptions, GetSecondarySliverOptions, GetSliversOptions, GetStorageConfirmationOptions, GetVerifiedBlobStatusOptions, ProtocolMessageCertificate, ReadBlobOptions, RegisterBlobOptions, SliversForNode, StorageNode, StorageWithSizeOptions, TipStrategy, UploadRelayConfig, UploadRelayTipConfig, WalrusClientConfig, WalrusClientExtensionOptions, WalrusClientRequestOptions, WalrusOptions, WalrusPackageConfig, WriteBlobAttributesOptions, WriteBlobFlow, WriteBlobFlowOptions, WriteBlobFlowRegisterOptions, WriteBlobFlowUploadOptions, WriteBlobOptions, WriteBlobToUploadRelayOptions, WriteEncodedBlobOptions, WriteEncodedBlobToNodesOptions, WriteFilesFlow, WriteFilesFlowOptions, WriteFilesFlowRegisterOptions, WriteFilesFlowUploadOptions, WriteFilesOptions, WriteMetadataOptions, WriteQuiltOptions, WriteSliverOptions, WriteSliversToNodeOptions };
//# sourceMappingURL=types.d.mts.map