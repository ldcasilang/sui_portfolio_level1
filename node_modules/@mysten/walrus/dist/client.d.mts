import { BlobStatus, GetSliverResponse, StorageConfirmation, StoreBlobMetadataResponse, StoreSliverResponse } from "./storage-node/types.mjs";
import { Blob } from "./contracts/walrus/blob.mjs";
import { WalrusFile } from "./files/file.mjs";
import { CertifyBlobOptions, ComputeBlobMetadataOptions, DeleteBlobOptions, EncodingType, ExtendBlobOptions, GetBlobMetadataOptions, GetSecondarySliverOptions, GetSliversOptions, GetStorageConfirmationOptions, GetVerifiedBlobStatusOptions, ProtocolMessageCertificate, ReadBlobOptions, RegisterBlobOptions, SliversForNode, StorageWithSizeOptions, WalrusClientConfig, WalrusOptions, WriteBlobAttributesOptions, WriteBlobFlow, WriteBlobFlowOptions, WriteBlobOptions, WriteBlobToUploadRelayOptions, WriteEncodedBlobOptions, WriteEncodedBlobToNodesOptions, WriteFilesFlow, WriteFilesFlowOptions, WriteFilesOptions, WriteMetadataOptions, WriteQuiltOptions, WriteSliverOptions, WriteSliversToNodeOptions } from "./types.mjs";
import { WalrusBlob } from "./files/blob.mjs";
import * as _mysten_bcs0 from "@mysten/bcs";
import { Transaction, TransactionResult } from "@mysten/sui/transactions";
import { ClientWithCoreApi } from "@mysten/sui/client";
import { Signer } from "@mysten/sui/cryptography";

//#region src/client.d.ts
declare function walrus<const Name = 'walrus'>({
  packageConfig,
  name,
  ...options
}?: WalrusOptions<Name>): {
  name: Name;
  register: (client: ClientWithCoreApi) => WalrusClient;
};
declare class WalrusClient {
  #private;
  constructor(config: WalrusClientConfig);
  /** The Move type for a Blob object */
  getBlobType(): string | Promise<string>;
  /** The cached system object for the walrus package */
  systemObject(): Promise<{
    id: string;
    version: string;
    package_id: string;
    new_package_id: string | null;
  }>;
  /** The cached staking pool object for the walrus package */
  stakingObject(): Promise<{
    id: string;
    version: string;
    package_id: string;
    new_package_id: string | null;
  }>;
  /** The system state for the current version of walrus contract  */
  systemState(): Promise<{
    committee: {
      members: {
        public_key: {
          bytes: number[];
        };
        weight: number;
        node_id: string;
      }[];
      n_shards: number;
      epoch: number;
      total_aggregated_key: {
        bytes: number[];
      };
    };
    total_capacity_size: string;
    used_capacity_size: string;
    storage_price_per_unit_size: string;
    write_price_per_unit_size: string;
    future_accounting: {
      current_index: number;
      length: number;
      ring_buffer: {
        epoch: number;
        used_capacity: string;
        rewards_to_distribute: {
          value: string;
        };
      }[];
    };
    event_blob_certification_state: {
      latest_certified_blob: {
        blob_id: string;
        ending_checkpoint_sequence_number: string;
      } | null;
      aggregate_weight_per_blob: {
        contents: {
          key: {
            blob_id: string;
            ending_checkpoint_sequence_number: string;
          };
          value: number;
        }[];
      };
    };
    deny_list_sizes: {
      id: string;
    };
  }>;
  /** The staking state for the current version of walrus contract */
  stakingState(): Promise<{
    n_shards: number;
    epoch_duration: string;
    first_epoch_start: string;
    pools: {
      id: string;
      size: string;
    };
    epoch: number;
    active_set: {
      id: string;
    };
    next_committee: {
      contents: {
        key: string;
        value: number[];
      }[];
    }[] | null;
    committee: {
      contents: {
        key: string;
        value: number[];
      }[];
    }[];
    previous_committee: {
      contents: {
        key: string;
        value: number[];
      }[];
    }[];
    next_epoch_params: {
      total_capacity_size: string;
      storage_price_per_unit_size: string;
      write_price_per_unit_size: string;
    } | null;
    epoch_state: _mysten_bcs0.EnumOutputShapeWithKeys<{
      EpochChangeSync: number;
      EpochChangeDone: string;
      NextParamsSelected: string;
    }, "EpochChangeSync" | "EpochChangeDone" | "NextParamsSelected">;
    next_epoch_public_keys: {
      id: string;
    };
  }>;
  /** Read a blob from the storage nodes */
  readBlob: ({
    blobId,
    signal
  }: ReadBlobOptions) => Promise<Uint8Array<ArrayBufferLike>>;
  computeBlobMetadata({
    bytes,
    numShards
  }: ComputeBlobMetadataOptions): Promise<{
    rootHash: Uint8Array<ArrayBufferLike>;
    blobId: string;
    metadata: {
      encodingType: EncodingType;
      unencodedLength: bigint;
    };
    nonce: Uint8Array<ArrayBuffer>;
    blobDigest: () => Promise<Uint8Array<ArrayBufferLike>>;
  }>;
  getBlobMetadata({
    blobId,
    signal
  }: GetBlobMetadataOptions): Promise<{
    blobId: string;
    metadata: {
      V1: {
        encoding_type: _mysten_bcs0.EnumOutputShapeWithKeys<{
          RedStuff: true;
          RS2: true;
        }, "RedStuff" | "RS2">;
        unencoded_length: string;
        hashes: {
          primary_hash: _mysten_bcs0.EnumOutputShapeWithKeys<{
            Empty: true;
            Digest: Uint8Array<ArrayBufferLike>;
          }, "Empty" | "Digest">;
          secondary_hash: _mysten_bcs0.EnumOutputShapeWithKeys<{
            Empty: true;
            Digest: Uint8Array<ArrayBufferLike>;
          }, "Empty" | "Digest">;
        }[];
      };
      $kind: "V1";
    };
  }>;
  getSecondarySliver: ({
    blobId,
    index,
    signal
  }: GetSecondarySliverOptions) => Promise<GetSliverResponse>;
  internalGetSecondarySliver({
    blobId,
    index,
    signal
  }: GetSecondarySliverOptions): Promise<GetSliverResponse>;
  getSlivers({
    blobId,
    signal
  }: GetSliversOptions): Promise<GetSliverResponse[]>;
  /**
   * Gets the blob status from multiple storage nodes and returns the latest status that can be verified.
   */
  getVerifiedBlobStatus({
    blobId,
    signal
  }: GetVerifiedBlobStatusOptions): Promise<BlobStatus>;
  /**
   * Calculate the cost of storing a blob for a given a size and number of epochs.
   */
  storageCost(size: number, epochs: number): Promise<{
    storageCost: bigint;
    writeCost: bigint;
    totalCost: bigint;
  }>;
  /**
   * A utility for creating a storage object in a transaction.
   *
   * @example
   * ```ts
   * tx.transferObjects([client.createStorage({ size: 1000, epochs: 3 })], owner);
   * ```
   */
  createStorage({
    size,
    epochs,
    walCoin
  }: StorageWithSizeOptions): (tx: Transaction) => Promise<TransactionResult>;
  /**
   * Create a transaction that creates a storage object
   *
   * @example
   * ```ts
   * const tx = client.createStorageTransaction({ size: 1000, epochs: 3, owner: signer.toSuiAddress() });
   * ```
   */
  createStorageTransaction({
    transaction,
    size,
    epochs,
    owner
  }: StorageWithSizeOptions & {
    transaction?: Transaction;
    /** Address the storage resource should be transferred to */
    owner: string;
  }): Transaction;
  /**
   * Execute a transaction that creates a storage object
   *
   * @example
   * ```ts
   * const { digest, storage } = await client.executeCreateStorageTransaction({ size: 1000, epochs: 3, signer });
   * ```
   */
  executeCreateStorageTransaction({
    signer,
    ...options
  }: StorageWithSizeOptions & {
    transaction?: Transaction;
    signer: Signer;
  }): Promise<{
    digest: string;
    storage: {
      id: string;
      start_epoch: number;
      end_epoch: number;
      storage_size: string;
    };
  }>;
  /**
   * Register a blob in a transaction
   *
   * @example
   * ```ts
   * tx.transferObjects([client.registerBlob({ size: 1000, epochs: 3, blobId, rootHash, deletable: true })], owner);
   * ```
   */
  registerBlob({
    size,
    epochs,
    blobId,
    rootHash,
    deletable,
    walCoin,
    attributes
  }: RegisterBlobOptions): (tx: Transaction) => Promise<TransactionResult>;
  addAuthPayload({
    size,
    blobDigest,
    nonce
  }: {
    size: number;
    blobDigest: Uint8Array | (() => Promise<Uint8Array>);
    nonce: Uint8Array;
  }): (transaction: Transaction) => Promise<void>;
  calculateUploadRelayTip(options: {
    size: number;
  }): Promise<number | bigint>;
  sendUploadRelayTip({
    size,
    blobDigest,
    nonce
  }: {
    size: number;
    blobDigest: Uint8Array | (() => Promise<Uint8Array>);
    nonce: Uint8Array;
  }): (transaction: Transaction) => Promise<void>;
  /**
   * Create a transaction that registers a blob
   *
   * @example
   * ```ts
   * const tx = client.registerBlobTransaction({ size: 1000, epochs: 3, blobId, rootHash, deletable: true });
   * ```
   */
  registerBlobTransaction({
    transaction,
    ...options
  }: RegisterBlobOptions & {
    transaction?: Transaction;
    /** Address the blob should be transferred to */
    owner: string;
  }): Transaction;
  /**
   * Execute a transaction that registers a blob
   *
   * @example
   * ```ts
   * const { digest, blob } = await client.executeRegisterBlobTransaction({ size: 1000, epochs: 3, signer });
   * ```
   */
  executeRegisterBlobTransaction({
    signer,
    ...options
  }: RegisterBlobOptions & {
    transaction?: Transaction;
    signer: Signer;
    /** Address the blob should be transferred to */
    owner?: string;
  }): Promise<{
    blob: (typeof Blob)['$inferType'];
    digest: string;
  }>;
  certificateFromConfirmations({
    confirmations,
    blobId,
    deletable,
    blobObjectId
  }: Extract<CertifyBlobOptions, {
    confirmations: unknown[];
  }>): Promise<ProtocolMessageCertificate>;
  /**
   * Certify a blob in a transaction
   *
   * @example
   * ```ts
   * tx.add(client.certifyBlob({ blobId, blobObjectId, confirmations }));
   * ```
   */
  certifyBlob({
    blobId,
    blobObjectId,
    confirmations,
    certificate,
    deletable
  }: CertifyBlobOptions): (tx: Transaction) => Promise<void>;
  /**
   * Create a transaction that certifies a blob
   *
   * @example
   * ```ts
   * const tx = client.certifyBlobTransaction({ blobId, blobObjectId, confirmations });
   * ```
   */
  certifyBlobTransaction({
    transaction,
    ...options
  }: CertifyBlobOptions & {
    transaction?: Transaction;
  }): Transaction;
  /**
   * Execute a transaction that certifies a blob
   *
   * @example
   * ```ts
   * const { digest } = await client.executeCertifyBlobTransaction({ blobId, blobObjectId, confirmations, signer });
   * ```
   */
  executeCertifyBlobTransaction({
    signer,
    ...options
  }: CertifyBlobOptions & {
    transaction?: Transaction;
    signer: Signer;
  }): Promise<{
    digest: string;
  }>;
  /**
   * Delete a blob in a transaction
   *
   * @example
   * ```ts
   * const storage = await client.deleteBlob({ blobObjectId });
   * tx.transferObjects([storage], owner);
   * ```
   */
  deleteBlob({
    blobObjectId
  }: DeleteBlobOptions): (tx: Transaction) => Promise<TransactionResult>;
  /**
   * Create a transaction that deletes a blob
   *
   * @example
   * ```ts
   * const tx = client.deleteBlobTransaction({ blobObjectId, owner });
   * ```
   */
  deleteBlobTransaction({
    owner,
    blobObjectId,
    transaction
  }: DeleteBlobOptions & {
    transaction?: Transaction;
    /** Address the storage resource should be returned to */
    owner: string;
  }): Transaction;
  /**
   * Execute a transaction that deletes a blob
   *
   * @example
   * ```ts
   * const { digest } = await client.executeDeleteBlobTransaction({ blobObjectId, signer });
   * ```
   */
  executeDeleteBlobTransaction({
    signer,
    transaction,
    blobObjectId
  }: DeleteBlobOptions & {
    signer: Signer;
    transaction?: Transaction;
  }): Promise<{
    digest: string;
  }>;
  /**
   * Extend a blob in a transaction
   *
   * @example
   * ```ts
   * const tx = client.extendBlobTransaction({ blobObjectId, epochs });
   * ```
   */
  extendBlob({
    blobObjectId,
    epochs,
    endEpoch,
    walCoin
  }: ExtendBlobOptions): (tx: Transaction) => Promise<void>;
  /**
   * Create a transaction that extends a blob
   *
   * @example
   * ```ts
   * const tx = client.extendBlobTransaction({ blobObjectId, epochs });
   * ```
   */
  extendBlobTransaction({
    transaction,
    ...options
  }: ExtendBlobOptions & {
    transaction?: Transaction;
  }): Promise<Transaction>;
  /**
   * Execute a transaction that extends a blob
   *
   * @example
   * ```ts
   * const { digest } = await client.executeExtendBlobTransaction({ blobObjectId, signer });
   * ```
   */
  executeExtendBlobTransaction({
    signer,
    ...options
  }: ExtendBlobOptions & {
    signer: Signer;
    transaction?: Transaction;
  }): Promise<{
    digest: string;
  }>;
  readBlobAttributes({
    blobObjectId
  }: {
    blobObjectId: string;
  }): Promise<Record<string, string> | null>;
  /**
   * Write attributes to a blob
   *
   * If attributes already exists, their previous values will be overwritten
   * If an attribute is set to `null`, it will be removed from the blob
   *
   * @example
   * ```ts
   * tx.add(client.writeBlobAttributes({ blobObjectId, attributes: { key: 'value', keyToRemove: null } }));
   * ```
   */
  writeBlobAttributes({
    blobObject,
    blobObjectId,
    attributes
  }: WriteBlobAttributesOptions): (tx: Transaction) => Promise<void>;
  /**
   * Create a transaction that writes attributes to a blob
   *
   * If attributes already exists, their previous values will be overwritten
   * If an attribute is set to `null`, it will be removed from the blob
   *
   * @example
   * ```ts
   * const tx = client.writeBlobAttributesTransaction({ blobObjectId, attributes: { key: 'value', keyToRemove: null } });
   * ```
   */
  writeBlobAttributesTransaction({
    transaction,
    ...options
  }: WriteBlobAttributesOptions & {
    transaction?: Transaction;
  }): Promise<Transaction>;
  /**
   * Execute a transaction that writes attributes to a blob
   *
   * If attributes already exists, their previous values will be overwritten
   * If an attribute is set to `null`, it will be removed from the blob
   *
   * @example
   * ```ts
   * const { digest } = await client.executeWriteBlobAttributesTransaction({ blobObjectId, signer });
   * ```
   */
  executeWriteBlobAttributesTransaction({
    signer,
    ...options
  }: WriteBlobAttributesOptions & {
    signer: Signer;
    transaction?: Transaction;
  }): Promise<{
    digest: string;
  }>;
  /**
   * Write a sliver to a storage node
   *
   * @example
   * ```ts
   * const res = await client.writeSliver({ blobId, sliverPairIndex, sliverType, sliver });
   * ```
   */
  writeSliver({
    blobId,
    sliverPairIndex,
    sliverType,
    sliver,
    signal
  }: WriteSliverOptions): Promise<StoreSliverResponse>;
  /**
   * Write metadata to a storage node
   *
   * @example
   * ```ts
   * const res = await client.writeMetadataToNode({ nodeIndex, blobId, metadata });
   * ```
   */
  writeMetadataToNode({
    nodeIndex,
    blobId,
    metadata,
    signal
  }: WriteMetadataOptions): Promise<StoreBlobMetadataResponse>;
  /**
   * Get a storage confirmation from a storage node
   *
   * @example
   * ```ts
   * const confirmation = await client.getStorageConfirmationFromNode({ nodeIndex, blobId, deletable, objectId });
   * ```
   */
  getStorageConfirmationFromNode({
    nodeIndex,
    blobId,
    deletable,
    objectId,
    signal
  }: GetStorageConfirmationOptions): Promise<StorageConfirmation>;
  /**
   * Encode a blob into slivers for each node
   *
   * @example
   * ```ts
   * const { blobId, metadata, sliversByNode, rootHash } = await client.encodeBlob(blob);
   * ```
   */
  encodeBlob(blob: Uint8Array): Promise<{
    blobId: string;
    metadata: {
      V1: {
        encoding_type: "RedStuff" | "RS2" | {
          RedStuff: boolean | object | null;
        } | {
          RS2: boolean | object | null;
        };
        unencoded_length: string | number | bigint;
        hashes: Iterable<{
          primary_hash: _mysten_bcs0.EnumInputShape<{
            Empty: boolean | object | null;
            Digest: Iterable<number>;
          }>;
          secondary_hash: _mysten_bcs0.EnumInputShape<{
            Empty: boolean | object | null;
            Digest: Iterable<number>;
          }>;
        }> & {
          length: number;
        };
      };
    };
    rootHash: Uint8Array<ArrayBufferLike>;
    sliversByNode: SliversForNode[];
  }>;
  /**
   * Write slivers to a storage node
   *
   * @example
   * ```ts
   * await client.writeSliversToNode({ blobId, slivers, signal });
   * ```
   */
  writeSliversToNode({
    blobId,
    slivers,
    signal
  }: WriteSliversToNodeOptions): Promise<void>;
  /**
   * Write a blob to all storage nodes
   *
   * @example
   * ```ts
   * await client.writeEncodedBlobToNodes({ blob, deletable, epochs, signer });
   * ```
   */
  writeEncodedBlobToNodes({
    blobId,
    metadata,
    sliversByNode,
    signal,
    ...options
  }: WriteEncodedBlobToNodesOptions): Promise<(StorageConfirmation | null)[]>;
  /**
   * Writes a blob to to an upload relay
   *
   * @example
   * ```ts
   * await client.writeBlobToUploadRelay({ blob, deletable, epochs, signer });
   * ```
   */
  writeBlobToUploadRelay(options: WriteBlobToUploadRelayOptions): Promise<{
    blobId: string;
    certificate: ProtocolMessageCertificate;
  }>;
  /**
   * Write encoded blob to a storage node
   *
   * @example
   * ```ts
   * const res = await client.writeEncodedBlobToNode({ nodeIndex, blobId, metadata, slivers });
   * ```
   */
  writeEncodedBlobToNode({
    nodeIndex,
    blobId,
    metadata,
    slivers,
    signal,
    ...options
  }: WriteEncodedBlobOptions): Promise<StorageConfirmation>;
  /**
   * Write a blob to all storage nodes
   *
   * @example
   * ```ts
   * const { blobId, blobObject } = await client.writeBlob({ blob, deletable, epochs, signer });
   * ```
   */
  writeBlob({
    blob,
    deletable,
    epochs,
    signer,
    signal,
    owner,
    attributes
  }: WriteBlobOptions): Promise<{
    blobId: string;
    blobObject: {
      id: string;
      registered_epoch: number;
      blob_id: string;
      size: string;
      encoding_type: number;
      certified_epoch: number | null;
      storage: {
        id: string;
        start_epoch: number;
        end_epoch: number;
        storage_size: string;
      };
      deletable: boolean;
    };
  }>;
  writeQuilt({
    blobs,
    ...options
  }: WriteQuiltOptions): Promise<{
    index: {
      patches: {
        patchId: string;
        endIndex: number;
        identifier: string;
        tags: Record<string, string> | Map<string, string>;
        startIndex: number;
      }[];
    };
    blobId: string;
    blobObject: {
      id: string;
      registered_epoch: number;
      blob_id: string;
      size: string;
      encoding_type: number;
      certified_epoch: number | null;
      storage: {
        id: string;
        start_epoch: number;
        end_epoch: number;
        storage_size: string;
      };
      deletable: boolean;
    };
  }>;
  encodeQuilt({
    blobs
  }: {
    blobs: {
      contents: Uint8Array;
      identifier: string;
      tags?: Record<string, string>;
    }[];
  }): Promise<{
    quilt: Uint8Array<ArrayBuffer>;
    index: {
      patches: ({
        endIndex: number;
        identifier: string;
        tags: Record<string, string> | Map<string, string>;
      } & {
        startIndex: number;
      })[];
    };
  }>;
  /**
   * Reset cached data in the client
   *
   * @example
   * ```ts
   * client.reset();
   * ```
   */
  reset(): void;
  getBlob({
    blobId
  }: {
    blobId: string;
  }): Promise<WalrusBlob>;
  getFiles({
    ids
  }: {
    ids: string[];
  }): Promise<WalrusFile[]>;
  writeFiles({
    files,
    ...options
  }: WriteFilesOptions): Promise<{
    id: string;
    blobId: string;
    blobObject: {
      id: string;
      registered_epoch: number;
      blob_id: string;
      size: string;
      encoding_type: number;
      certified_epoch: number | null;
      storage: {
        id: string;
        start_epoch: number;
        end_epoch: number;
        storage_size: string;
      };
      deletable: boolean;
    };
  }[]>;
  writeFilesFlow({
    files
  }: WriteFilesFlowOptions): WriteFilesFlow;
  writeBlobFlow({
    blob
  }: WriteBlobFlowOptions): WriteBlobFlow;
}
//#endregion
export { WalrusClient, walrus };
//# sourceMappingURL=client.d.mts.map