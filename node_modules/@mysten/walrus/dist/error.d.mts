//#region src/error.d.ts
declare class WalrusClientError extends Error {}
declare class RetryableWalrusClientError extends WalrusClientError {}
/** Thrown when the client could not retrieve the status of a blob from any storage node. */
declare class NoBlobStatusReceivedError extends WalrusClientError {}
/** Thrown when the client could not retrieve a verified blob status for the blob. */
declare class NoVerifiedBlobStatusReceivedError extends WalrusClientError {}
/** Thrown when the client could not retrieve blob metadata from any storage node. */
declare class NoBlobMetadataReceivedError extends RetryableWalrusClientError {}
/** Thrown when the client could not retrieve enough slivers to reconstruct the blob. */
declare class NotEnoughSliversReceivedError extends RetryableWalrusClientError {}
/** Thrown when the client could not write enough slivers to upload the blob. */
declare class NotEnoughBlobConfirmationsError extends RetryableWalrusClientError {}
/** Thrown when the client is currently behind the current epoch. */
declare class BehindCurrentEpochError extends RetryableWalrusClientError {}
/** Thrown when a blob is not certified or determined to not exist. */
declare class BlobNotCertifiedError extends RetryableWalrusClientError {}
/** Thrown when a blob was determined to be incorrectly encoded. */
declare class InconsistentBlobError extends WalrusClientError {}
/** Thrown when blob is blocked by a quorum of storage nodes. */
declare class BlobBlockedError extends Error {}
//#endregion
export { BehindCurrentEpochError, BlobBlockedError, BlobNotCertifiedError, InconsistentBlobError, NoBlobMetadataReceivedError, NoBlobStatusReceivedError, NoVerifiedBlobStatusReceivedError, NotEnoughBlobConfirmationsError, NotEnoughSliversReceivedError, RetryableWalrusClientError, WalrusClientError };
//# sourceMappingURL=error.d.mts.map