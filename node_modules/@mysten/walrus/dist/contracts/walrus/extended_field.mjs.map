{"version":3,"file":"extended_field.mjs","names":[],"sources":["../../../src/contracts/walrus/extended_field.ts"],"sourcesContent":["/**************************************************************\n * THIS FILE IS GENERATED AND SHOULD NOT BE MANUALLY MODIFIED *\n **************************************************************/\n\n/** Module: extended_field */\n\nimport {\n\tMoveStruct,\n\tMoveTuple,\n\tnormalizeMoveArguments,\n\ttype RawTransactionArgument,\n} from '../utils/index.js';\nimport { bcs, type BcsType } from '@mysten/sui/bcs';\nimport { type Transaction } from '@mysten/sui/transactions';\nconst $moduleName = '@local-pkg/walrus::extended_field';\nexport const ExtendedField = new MoveStruct({\n\tname: `${$moduleName}::ExtendedField`,\n\tfields: {\n\t\tid: bcs.Address,\n\t},\n});\nexport const Key = new MoveTuple({ name: `${$moduleName}::Key`, fields: [bcs.bool()] });\nexport interface NewArguments<T extends BcsType<any>> {\n\tvalue: RawTransactionArgument<T>;\n}\nexport interface NewOptions<T extends BcsType<any>> {\n\tpackage?: string;\n\targuments: NewArguments<T> | [value: RawTransactionArgument<T>];\n\ttypeArguments: [string];\n}\n/** Creates a new extended field with the given value. */\nexport function _new<T extends BcsType<any>>(options: NewOptions<T>) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${options.typeArguments[0]}`] satisfies (string | null)[];\n\tconst parameterNames = ['value'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'extended_field',\n\t\t\tfunction: 'new',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t\ttypeArguments: options.typeArguments,\n\t\t});\n}\nexport interface BorrowArguments {\n\tfield: RawTransactionArgument<string>;\n}\nexport interface BorrowOptions {\n\tpackage?: string;\n\targuments: BorrowArguments | [field: RawTransactionArgument<string>];\n\ttypeArguments: [string];\n}\n/** Borrows the value stored in the extended field. */\nexport function borrow(options: BorrowOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null] satisfies (string | null)[];\n\tconst parameterNames = ['field'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'extended_field',\n\t\t\tfunction: 'borrow',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t\ttypeArguments: options.typeArguments,\n\t\t});\n}\nexport interface BorrowMutArguments {\n\tfield: RawTransactionArgument<string>;\n}\nexport interface BorrowMutOptions {\n\tpackage?: string;\n\targuments: BorrowMutArguments | [field: RawTransactionArgument<string>];\n\ttypeArguments: [string];\n}\n/** Borrows the value stored in the extended field mutably. */\nexport function borrowMut(options: BorrowMutOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null] satisfies (string | null)[];\n\tconst parameterNames = ['field'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'extended_field',\n\t\t\tfunction: 'borrow_mut',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t\ttypeArguments: options.typeArguments,\n\t\t});\n}\nexport interface SwapArguments<T extends BcsType<any>> {\n\tfield: RawTransactionArgument<string>;\n\tvalue: RawTransactionArgument<T>;\n}\nexport interface SwapOptions<T extends BcsType<any>> {\n\tpackage?: string;\n\targuments:\n\t\t| SwapArguments<T>\n\t\t| [field: RawTransactionArgument<string>, value: RawTransactionArgument<T>];\n\ttypeArguments: [string];\n}\n/** Swaps the value stored in the extended field with the given value. */\nexport function swap<T extends BcsType<any>>(options: SwapOptions<T>) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null, `${options.typeArguments[0]}`] satisfies (string | null)[];\n\tconst parameterNames = ['field', 'value'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'extended_field',\n\t\t\tfunction: 'swap',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t\ttypeArguments: options.typeArguments,\n\t\t});\n}\nexport interface DestroyArguments {\n\tfield: RawTransactionArgument<string>;\n}\nexport interface DestroyOptions {\n\tpackage?: string;\n\targuments: DestroyArguments | [field: RawTransactionArgument<string>];\n\ttypeArguments: [string];\n}\n/** Destroys the extended field and returns the value stored in it. */\nexport function destroy(options: DestroyOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null] satisfies (string | null)[];\n\tconst parameterNames = ['field'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'extended_field',\n\t\t\tfunction: 'destroy',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t\ttypeArguments: options.typeArguments,\n\t\t});\n}\n"],"mappings":";;;;;;;;AAcA,MAAM,cAAc;AACpB,MAAa,gBAAgB,IAAI,WAAW;CAC3C,MAAM,GAAG,YAAY;CACrB,QAAQ,EACP,IAAI,IAAI,SACR;CACD,CAAC;AACF,MAAa,MAAM,IAAI,UAAU;CAAE,MAAM,GAAG,YAAY;CAAQ,QAAQ,CAAC,IAAI,MAAM,CAAC;CAAE,CAAC"}