{"version":3,"file":"system.mjs","names":[],"sources":["../../../src/contracts/walrus/system.ts"],"sourcesContent":["/**************************************************************\n * THIS FILE IS GENERATED AND SHOULD NOT BE MANUALLY MODIFIED *\n **************************************************************/\n\n/** Module: system */\n\nimport { MoveStruct, normalizeMoveArguments, type RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport { type Transaction } from '@mysten/sui/transactions';\nconst $moduleName = '@local-pkg/walrus::system';\nexport const System = new MoveStruct({\n\tname: `${$moduleName}::System`,\n\tfields: {\n\t\tid: bcs.Address,\n\t\tversion: bcs.u64(),\n\t\tpackage_id: bcs.Address,\n\t\tnew_package_id: bcs.option(bcs.Address),\n\t},\n});\nexport interface InvalidateBlobIdArguments {\n\tsystem: RawTransactionArgument<string>;\n\tsignature: RawTransactionArgument<number[]>;\n\tmembersBitmap: RawTransactionArgument<number[]>;\n\tmessage: RawTransactionArgument<number[]>;\n}\nexport interface InvalidateBlobIdOptions {\n\tpackage?: string;\n\targuments:\n\t\t| InvalidateBlobIdArguments\n\t\t| [\n\t\t\t\tsystem: RawTransactionArgument<string>,\n\t\t\t\tsignature: RawTransactionArgument<number[]>,\n\t\t\t\tmembersBitmap: RawTransactionArgument<number[]>,\n\t\t\t\tmessage: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/**\n * === Public Functions === Marks blob as invalid given an invalid blob\n * certificate.\n */\nexport function invalidateBlobId(options: InvalidateBlobIdOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null, 'vector<u8>', 'vector<u8>', 'vector<u8>'] satisfies (\n\t\t| string\n\t\t| null\n\t)[];\n\tconst parameterNames = ['system', 'signature', 'membersBitmap', 'message'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'invalidate_blob_id',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface CertifyEventBlobArguments {\n\tsystem: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tblobId: RawTransactionArgument<number | bigint>;\n\trootHash: RawTransactionArgument<number | bigint>;\n\tsize: RawTransactionArgument<number | bigint>;\n\tencodingType: RawTransactionArgument<number>;\n\tendingCheckpointSequenceNum: RawTransactionArgument<number | bigint>;\n\tepoch: RawTransactionArgument<number>;\n}\nexport interface CertifyEventBlobOptions {\n\tpackage?: string;\n\targuments:\n\t\t| CertifyEventBlobArguments\n\t\t| [\n\t\t\t\tsystem: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tblobId: RawTransactionArgument<number | bigint>,\n\t\t\t\trootHash: RawTransactionArgument<number | bigint>,\n\t\t\t\tsize: RawTransactionArgument<number | bigint>,\n\t\t\t\tencodingType: RawTransactionArgument<number>,\n\t\t\t\tendingCheckpointSequenceNum: RawTransactionArgument<number | bigint>,\n\t\t\t\tepoch: RawTransactionArgument<number>,\n\t\t  ];\n}\n/** Certifies a blob containing Walrus events. */\nexport function certifyEventBlob(options: CertifyEventBlobOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null, null, 'u256', 'u256', 'u64', 'u8', 'u64', 'u32'] satisfies (\n\t\t| string\n\t\t| null\n\t)[];\n\tconst parameterNames = [\n\t\t'system',\n\t\t'cap',\n\t\t'blobId',\n\t\t'rootHash',\n\t\t'size',\n\t\t'encodingType',\n\t\t'endingCheckpointSequenceNum',\n\t\t'epoch',\n\t];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'certify_event_blob',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ReserveSpaceArguments {\n\tself: RawTransactionArgument<string>;\n\tstorageAmount: RawTransactionArgument<number | bigint>;\n\tepochsAhead: RawTransactionArgument<number>;\n\tpayment: RawTransactionArgument<string>;\n}\nexport interface ReserveSpaceOptions {\n\tpackage?: string;\n\targuments:\n\t\t| ReserveSpaceArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tstorageAmount: RawTransactionArgument<number | bigint>,\n\t\t\t\tepochsAhead: RawTransactionArgument<number>,\n\t\t\t\tpayment: RawTransactionArgument<string>,\n\t\t  ];\n}\n/** Allows buying a storage reservation for a given period of epochs. */\nexport function reserveSpace(options: ReserveSpaceOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null, 'u64', 'u32', null] satisfies (string | null)[];\n\tconst parameterNames = ['self', 'storageAmount', 'epochsAhead', 'payment'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'reserve_space',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ReserveSpaceForEpochsArguments {\n\tself: RawTransactionArgument<string>;\n\tstorageAmount: RawTransactionArgument<number | bigint>;\n\tstartEpoch: RawTransactionArgument<number>;\n\tendEpoch: RawTransactionArgument<number>;\n\tpayment: RawTransactionArgument<string>;\n}\nexport interface ReserveSpaceForEpochsOptions {\n\tpackage?: string;\n\targuments:\n\t\t| ReserveSpaceForEpochsArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tstorageAmount: RawTransactionArgument<number | bigint>,\n\t\t\t\tstartEpoch: RawTransactionArgument<number>,\n\t\t\t\tendEpoch: RawTransactionArgument<number>,\n\t\t\t\tpayment: RawTransactionArgument<string>,\n\t\t  ];\n}\n/**\n * Allows buying a storage reservation for a given period of epochs.\n *\n * Returns a storage resource for the period between `start_epoch` (inclusive) and\n * `end_epoch` (exclusive). If `start_epoch` has already passed, reserves space\n * starting from the current epoch.\n */\nexport function reserveSpaceForEpochs(options: ReserveSpaceForEpochsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null, 'u64', 'u32', 'u32', null] satisfies (string | null)[];\n\tconst parameterNames = ['self', 'storageAmount', 'startEpoch', 'endEpoch', 'payment'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'reserve_space_for_epochs',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RegisterBlobArguments {\n\tself: RawTransactionArgument<string>;\n\tstorage: RawTransactionArgument<string>;\n\tblobId: RawTransactionArgument<number | bigint>;\n\trootHash: RawTransactionArgument<number | bigint>;\n\tsize: RawTransactionArgument<number | bigint>;\n\tencodingType: RawTransactionArgument<number>;\n\tdeletable: RawTransactionArgument<boolean>;\n\twritePayment: RawTransactionArgument<string>;\n}\nexport interface RegisterBlobOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RegisterBlobArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tstorage: RawTransactionArgument<string>,\n\t\t\t\tblobId: RawTransactionArgument<number | bigint>,\n\t\t\t\trootHash: RawTransactionArgument<number | bigint>,\n\t\t\t\tsize: RawTransactionArgument<number | bigint>,\n\t\t\t\tencodingType: RawTransactionArgument<number>,\n\t\t\t\tdeletable: RawTransactionArgument<boolean>,\n\t\t\t\twritePayment: RawTransactionArgument<string>,\n\t\t  ];\n}\n/**\n * Registers a new blob in the system. `size` is the size of the unencoded blob.\n * The reserved space in `storage` must be at least the size of the encoded blob.\n */\nexport function registerBlob(options: RegisterBlobOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null, null, 'u256', 'u256', 'u64', 'u8', 'bool', null] satisfies (\n\t\t| string\n\t\t| null\n\t)[];\n\tconst parameterNames = [\n\t\t'self',\n\t\t'storage',\n\t\t'blobId',\n\t\t'rootHash',\n\t\t'size',\n\t\t'encodingType',\n\t\t'deletable',\n\t\t'writePayment',\n\t];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'register_blob',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface CertifyBlobArguments {\n\tself: RawTransactionArgument<string>;\n\tblob: RawTransactionArgument<string>;\n\tsignature: RawTransactionArgument<number[]>;\n\tsignersBitmap: RawTransactionArgument<number[]>;\n\tmessage: RawTransactionArgument<number[]>;\n}\nexport interface CertifyBlobOptions {\n\tpackage?: string;\n\targuments:\n\t\t| CertifyBlobArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tblob: RawTransactionArgument<string>,\n\t\t\t\tsignature: RawTransactionArgument<number[]>,\n\t\t\t\tsignersBitmap: RawTransactionArgument<number[]>,\n\t\t\t\tmessage: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/**\n * Certify that a blob will be available in the storage system until the end epoch\n * of the storage associated with it.\n */\nexport function certifyBlob(options: CertifyBlobOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null, null, 'vector<u8>', 'vector<u8>', 'vector<u8>'] satisfies (\n\t\t| string\n\t\t| null\n\t)[];\n\tconst parameterNames = ['self', 'blob', 'signature', 'signersBitmap', 'message'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'certify_blob',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface DeleteBlobArguments {\n\tself: RawTransactionArgument<string>;\n\tblob: RawTransactionArgument<string>;\n}\nexport interface DeleteBlobOptions {\n\tpackage?: string;\n\targuments:\n\t\t| DeleteBlobArguments\n\t\t| [self: RawTransactionArgument<string>, blob: RawTransactionArgument<string>];\n}\n/** Deletes a deletable blob and returns the contained storage resource. */\nexport function deleteBlob(options: DeleteBlobOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null, null] satisfies (string | null)[];\n\tconst parameterNames = ['self', 'blob'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'delete_blob',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ExtendBlobWithResourceArguments {\n\tself: RawTransactionArgument<string>;\n\tblob: RawTransactionArgument<string>;\n\textension: RawTransactionArgument<string>;\n}\nexport interface ExtendBlobWithResourceOptions {\n\tpackage?: string;\n\targuments:\n\t\t| ExtendBlobWithResourceArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tblob: RawTransactionArgument<string>,\n\t\t\t\textension: RawTransactionArgument<string>,\n\t\t  ];\n}\n/**\n * Extend the period of validity of a blob with a new storage resource. The new\n * storage resource must be the same size as the storage resource used in the blob,\n * and have a longer period of validity.\n */\nexport function extendBlobWithResource(options: ExtendBlobWithResourceOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null, null, null] satisfies (string | null)[];\n\tconst parameterNames = ['self', 'blob', 'extension'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'extend_blob_with_resource',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ExtendBlobArguments {\n\tself: RawTransactionArgument<string>;\n\tblob: RawTransactionArgument<string>;\n\textendedEpochs: RawTransactionArgument<number>;\n\tpayment: RawTransactionArgument<string>;\n}\nexport interface ExtendBlobOptions {\n\tpackage?: string;\n\targuments:\n\t\t| ExtendBlobArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tblob: RawTransactionArgument<string>,\n\t\t\t\textendedEpochs: RawTransactionArgument<number>,\n\t\t\t\tpayment: RawTransactionArgument<string>,\n\t\t  ];\n}\n/**\n * Extend the period of validity of a blob by extending its contained storage\n * resource by `extended_epochs` epochs.\n */\nexport function extendBlob(options: ExtendBlobOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null, null, 'u32', null] satisfies (string | null)[];\n\tconst parameterNames = ['self', 'blob', 'extendedEpochs', 'payment'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'extend_blob',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface AddSubsidyArguments {\n\tsystem: RawTransactionArgument<string>;\n\tsubsidy: RawTransactionArgument<string>;\n\tepochsAhead: RawTransactionArgument<number>;\n}\nexport interface AddSubsidyOptions {\n\tpackage?: string;\n\targuments:\n\t\t| AddSubsidyArguments\n\t\t| [\n\t\t\t\tsystem: RawTransactionArgument<string>,\n\t\t\t\tsubsidy: RawTransactionArgument<string>,\n\t\t\t\tepochsAhead: RawTransactionArgument<number>,\n\t\t  ];\n}\n/**\n * Adds rewards to the system for the specified number of epochs ahead. The rewards\n * are split equally across the future accounting ring buffer up to the specified\n * epoch.\n */\nexport function addSubsidy(options: AddSubsidyOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null, null, 'u32'] satisfies (string | null)[];\n\tconst parameterNames = ['system', 'subsidy', 'epochsAhead'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'add_subsidy',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface AddPerEpochSubsidiesArguments {\n\tsystem: RawTransactionArgument<string>;\n\tsubsidies: RawTransactionArgument<string[]>;\n}\nexport interface AddPerEpochSubsidiesOptions {\n\tpackage?: string;\n\targuments:\n\t\t| AddPerEpochSubsidiesArguments\n\t\t| [system: RawTransactionArgument<string>, subsidies: RawTransactionArgument<string[]>];\n}\n/**\n * Adds rewards to the system for future epochs, where `subsidies[i]` is added to\n * the rewards of epoch `system.epoch() + i`.\n */\nexport function addPerEpochSubsidies(options: AddPerEpochSubsidiesOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null, 'vector<null>'] satisfies (string | null)[];\n\tconst parameterNames = ['system', 'subsidies'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'add_per_epoch_subsidies',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface UpdateProtocolVersionArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tsignature: RawTransactionArgument<number[]>;\n\tmembersBitmap: RawTransactionArgument<number[]>;\n\tmessage: RawTransactionArgument<number[]>;\n}\nexport interface UpdateProtocolVersionOptions {\n\tpackage?: string;\n\targuments:\n\t\t| UpdateProtocolVersionArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tsignature: RawTransactionArgument<number[]>,\n\t\t\t\tmembersBitmap: RawTransactionArgument<number[]>,\n\t\t\t\tmessage: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/** Node collects signatures on the protocol version event and emits it. */\nexport function updateProtocolVersion(options: UpdateProtocolVersionOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null, null, 'vector<u8>', 'vector<u8>', 'vector<u8>'] satisfies (\n\t\t| string\n\t\t| null\n\t)[];\n\tconst parameterNames = ['self', 'cap', 'signature', 'membersBitmap', 'message'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'update_protocol_version',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RegisterDenyListUpdateArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tdenyListRoot: RawTransactionArgument<number | bigint>;\n\tdenyListSequence: RawTransactionArgument<number | bigint>;\n}\nexport interface RegisterDenyListUpdateOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RegisterDenyListUpdateArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tdenyListRoot: RawTransactionArgument<number | bigint>,\n\t\t\t\tdenyListSequence: RawTransactionArgument<number | bigint>,\n\t\t  ];\n}\n/** Register a deny list update. */\nexport function registerDenyListUpdate(options: RegisterDenyListUpdateOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null, null, 'u256', 'u64'] satisfies (string | null)[];\n\tconst parameterNames = ['self', 'cap', 'denyListRoot', 'denyListSequence'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'register_deny_list_update',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface UpdateDenyListArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tsignature: RawTransactionArgument<number[]>;\n\tmembersBitmap: RawTransactionArgument<number[]>;\n\tmessage: RawTransactionArgument<number[]>;\n}\nexport interface UpdateDenyListOptions {\n\tpackage?: string;\n\targuments:\n\t\t| UpdateDenyListArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tsignature: RawTransactionArgument<number[]>,\n\t\t\t\tmembersBitmap: RawTransactionArgument<number[]>,\n\t\t\t\tmessage: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/** Perform the update of the deny list. */\nexport function updateDenyList(options: UpdateDenyListOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null, null, 'vector<u8>', 'vector<u8>', 'vector<u8>'] satisfies (\n\t\t| string\n\t\t| null\n\t)[];\n\tconst parameterNames = ['self', 'cap', 'signature', 'membersBitmap', 'message'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'update_deny_list',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface DeleteDenyListedBlobArguments {\n\tself: RawTransactionArgument<string>;\n\tsignature: RawTransactionArgument<number[]>;\n\tmembersBitmap: RawTransactionArgument<number[]>;\n\tmessage: RawTransactionArgument<number[]>;\n}\nexport interface DeleteDenyListedBlobOptions {\n\tpackage?: string;\n\targuments:\n\t\t| DeleteDenyListedBlobArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tsignature: RawTransactionArgument<number[]>,\n\t\t\t\tmembersBitmap: RawTransactionArgument<number[]>,\n\t\t\t\tmessage: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/** Delete a blob that is deny listed by f+1 members. */\nexport function deleteDenyListedBlob(options: DeleteDenyListedBlobOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null, 'vector<u8>', 'vector<u8>', 'vector<u8>'] satisfies (\n\t\t| string\n\t\t| null\n\t)[];\n\tconst parameterNames = ['self', 'signature', 'membersBitmap', 'message'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'delete_deny_listed_blob',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface EpochArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface EpochOptions {\n\tpackage?: string;\n\targuments: EpochArguments | [self: RawTransactionArgument<string>];\n}\n/** Get epoch. Uses the committee to get the epoch. */\nexport function epoch(options: EpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null] satisfies (string | null)[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface TotalCapacitySizeArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface TotalCapacitySizeOptions {\n\tpackage?: string;\n\targuments: TotalCapacitySizeArguments | [self: RawTransactionArgument<string>];\n}\n/** Accessor for total capacity size. */\nexport function totalCapacitySize(options: TotalCapacitySizeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null] satisfies (string | null)[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'total_capacity_size',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface UsedCapacitySizeArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface UsedCapacitySizeOptions {\n\tpackage?: string;\n\targuments: UsedCapacitySizeArguments | [self: RawTransactionArgument<string>];\n}\n/** Accessor for used capacity size. */\nexport function usedCapacitySize(options: UsedCapacitySizeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null] satisfies (string | null)[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'used_capacity_size',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface NShardsArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface NShardsOptions {\n\tpackage?: string;\n\targuments: NShardsArguments | [self: RawTransactionArgument<string>];\n}\n/** Accessor for the number of shards. */\nexport function nShards(options: NShardsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null] satisfies (string | null)[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'n_shards',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface FutureAccountingArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface FutureAccountingOptions {\n\tpackage?: string;\n\targuments: FutureAccountingArguments | [self: RawTransactionArgument<string>];\n}\n/** Read-only access to the accounting ring buffer. */\nexport function futureAccounting(options: FutureAccountingOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null] satisfies (string | null)[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'future_accounting',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface VersionArguments {\n\tsystem: RawTransactionArgument<string>;\n}\nexport interface VersionOptions {\n\tpackage?: string;\n\targuments: VersionArguments | [system: RawTransactionArgument<string>];\n}\nexport function version(options: VersionOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null] satisfies (string | null)[];\n\tconst parameterNames = ['system'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'version',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n"],"mappings":";;;;;;;;AASA,MAAM,cAAc;AACpB,MAAa,SAAS,IAAI,WAAW;CACpC,MAAM,GAAG,YAAY;CACrB,QAAQ;EACP,IAAI,IAAI;EACR,SAAS,IAAI,KAAK;EAClB,YAAY,IAAI;EAChB,gBAAgB,IAAI,OAAO,IAAI,QAAQ;EACvC;CACD,CAAC;;AAyGF,SAAgB,aAAa,SAA8B;CAC1D,MAAM,iBAAiB,QAAQ,WAAW;CAC1C,MAAM,iBAAiB;EAAC;EAAM;EAAO;EAAO;EAAK;CACjD,MAAM,iBAAiB;EAAC;EAAQ;EAAiB;EAAe;EAAU;AAC1E,SAAQ,OACP,GAAG,SAAS;EACX,SAAS;EACT,QAAQ;EACR,UAAU;EACV,WAAW,uBAAuB,QAAQ,WAAW,gBAAgB,eAAe;EACpF,CAAC;;;;;;AAqEJ,SAAgB,aAAa,SAA8B;CAC1D,MAAM,iBAAiB,QAAQ,WAAW;CAC1C,MAAM,iBAAiB;EAAC;EAAM;EAAM;EAAQ;EAAQ;EAAO;EAAM;EAAQ;EAAK;CAI9E,MAAM,iBAAiB;EACtB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACD,SAAQ,OACP,GAAG,SAAS;EACX,SAAS;EACT,QAAQ;EACR,UAAU;EACV,WAAW,uBAAuB,QAAQ,WAAW,gBAAgB,eAAe;EACpF,CAAC;;;;;;AAyBJ,SAAgB,YAAY,SAA6B;CACxD,MAAM,iBAAiB,QAAQ,WAAW;CAC1C,MAAM,iBAAiB;EAAC;EAAM;EAAM;EAAc;EAAc;EAAa;CAI7E,MAAM,iBAAiB;EAAC;EAAQ;EAAQ;EAAa;EAAiB;EAAU;AAChF,SAAQ,OACP,GAAG,SAAS;EACX,SAAS;EACT,QAAQ;EACR,UAAU;EACV,WAAW,uBAAuB,QAAQ,WAAW,gBAAgB,eAAe;EACpF,CAAC;;;AAaJ,SAAgB,WAAW,SAA4B;CACtD,MAAM,iBAAiB,QAAQ,WAAW;CAC1C,MAAM,iBAAiB,CAAC,MAAM,KAAK;CACnC,MAAM,iBAAiB,CAAC,QAAQ,OAAO;AACvC,SAAQ,OACP,GAAG,SAAS;EACX,SAAS;EACT,QAAQ;EACR,UAAU;EACV,WAAW,uBAAuB,QAAQ,WAAW,gBAAgB,eAAe;EACpF,CAAC;;;;;;AAuDJ,SAAgB,WAAW,SAA4B;CACtD,MAAM,iBAAiB,QAAQ,WAAW;CAC1C,MAAM,iBAAiB;EAAC;EAAM;EAAM;EAAO;EAAK;CAChD,MAAM,iBAAiB;EAAC;EAAQ;EAAQ;EAAkB;EAAU;AACpE,SAAQ,OACP,GAAG,SAAS;EACX,SAAS;EACT,QAAQ;EACR,UAAU;EACV,WAAW,uBAAuB,QAAQ,WAAW,gBAAgB,eAAe;EACpF,CAAC"}