import { MoveStruct, normalizeMoveArguments } from "../utils/index.mjs";
import { bcs } from "@mysten/sui/bcs";

//#region src/contracts/walrus/system.ts
/**************************************************************
* THIS FILE IS GENERATED AND SHOULD NOT BE MANUALLY MODIFIED *
**************************************************************/
/** Module: system */
const $moduleName = "@local-pkg/walrus::system";
const System = new MoveStruct({
	name: `${$moduleName}::System`,
	fields: {
		id: bcs.Address,
		version: bcs.u64(),
		package_id: bcs.Address,
		new_package_id: bcs.option(bcs.Address)
	}
});
/** Allows buying a storage reservation for a given period of epochs. */
function reserveSpace(options) {
	const packageAddress = options.package ?? "@local-pkg/walrus";
	const argumentsTypes = [
		null,
		"u64",
		"u32",
		null
	];
	const parameterNames = [
		"self",
		"storageAmount",
		"epochsAhead",
		"payment"
	];
	return (tx) => tx.moveCall({
		package: packageAddress,
		module: "system",
		function: "reserve_space",
		arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
	});
}
/**
* Registers a new blob in the system. `size` is the size of the unencoded blob.
* The reserved space in `storage` must be at least the size of the encoded blob.
*/
function registerBlob(options) {
	const packageAddress = options.package ?? "@local-pkg/walrus";
	const argumentsTypes = [
		null,
		null,
		"u256",
		"u256",
		"u64",
		"u8",
		"bool",
		null
	];
	const parameterNames = [
		"self",
		"storage",
		"blobId",
		"rootHash",
		"size",
		"encodingType",
		"deletable",
		"writePayment"
	];
	return (tx) => tx.moveCall({
		package: packageAddress,
		module: "system",
		function: "register_blob",
		arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
	});
}
/**
* Certify that a blob will be available in the storage system until the end epoch
* of the storage associated with it.
*/
function certifyBlob(options) {
	const packageAddress = options.package ?? "@local-pkg/walrus";
	const argumentsTypes = [
		null,
		null,
		"vector<u8>",
		"vector<u8>",
		"vector<u8>"
	];
	const parameterNames = [
		"self",
		"blob",
		"signature",
		"signersBitmap",
		"message"
	];
	return (tx) => tx.moveCall({
		package: packageAddress,
		module: "system",
		function: "certify_blob",
		arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
	});
}
/** Deletes a deletable blob and returns the contained storage resource. */
function deleteBlob(options) {
	const packageAddress = options.package ?? "@local-pkg/walrus";
	const argumentsTypes = [null, null];
	const parameterNames = ["self", "blob"];
	return (tx) => tx.moveCall({
		package: packageAddress,
		module: "system",
		function: "delete_blob",
		arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
	});
}
/**
* Extend the period of validity of a blob by extending its contained storage
* resource by `extended_epochs` epochs.
*/
function extendBlob(options) {
	const packageAddress = options.package ?? "@local-pkg/walrus";
	const argumentsTypes = [
		null,
		null,
		"u32",
		null
	];
	const parameterNames = [
		"self",
		"blob",
		"extendedEpochs",
		"payment"
	];
	return (tx) => tx.moveCall({
		package: packageAddress,
		module: "system",
		function: "extend_blob",
		arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
	});
}

//#endregion
export { System, certifyBlob, deleteBlob, extendBlob, registerBlob, reserveSpace };
//# sourceMappingURL=system.mjs.map