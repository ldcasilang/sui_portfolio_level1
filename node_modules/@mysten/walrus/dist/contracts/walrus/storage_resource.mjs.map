{"version":3,"file":"storage_resource.mjs","names":[],"sources":["../../../src/contracts/walrus/storage_resource.ts"],"sourcesContent":["/**************************************************************\n * THIS FILE IS GENERATED AND SHOULD NOT BE MANUALLY MODIFIED *\n **************************************************************/\nimport { MoveStruct, normalizeMoveArguments, type RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport { type Transaction } from '@mysten/sui/transactions';\nconst $moduleName = '@local-pkg/walrus::storage_resource';\nexport const Storage = new MoveStruct({\n\tname: `${$moduleName}::Storage`,\n\tfields: {\n\t\tid: bcs.Address,\n\t\tstart_epoch: bcs.u32(),\n\t\tend_epoch: bcs.u32(),\n\t\tstorage_size: bcs.u64(),\n\t},\n});\nexport interface StartEpochArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface StartEpochOptions {\n\tpackage?: string;\n\targuments: StartEpochArguments | [self: RawTransactionArgument<string>];\n}\nexport function startEpoch(options: StartEpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null] satisfies (string | null)[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'start_epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface EndEpochArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface EndEpochOptions {\n\tpackage?: string;\n\targuments: EndEpochArguments | [self: RawTransactionArgument<string>];\n}\nexport function endEpoch(options: EndEpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null] satisfies (string | null)[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'end_epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SizeArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface SizeOptions {\n\tpackage?: string;\n\targuments: SizeArguments | [self: RawTransactionArgument<string>];\n}\nexport function size(options: SizeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null] satisfies (string | null)[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'size',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SplitByEpochArguments {\n\tstorage: RawTransactionArgument<string>;\n\tsplitEpoch: RawTransactionArgument<number>;\n}\nexport interface SplitByEpochOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SplitByEpochArguments\n\t\t| [storage: RawTransactionArgument<string>, splitEpoch: RawTransactionArgument<number>];\n}\n/**\n * Splits the storage object into two based on `split_epoch`.\n *\n * `storage` is modified to cover the period from `start_epoch` to `split_epoch`\n * and a new storage object covering `split_epoch` to `end_epoch` is returned.\n */\nexport function splitByEpoch(options: SplitByEpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null, 'u32'] satisfies (string | null)[];\n\tconst parameterNames = ['storage', 'splitEpoch'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'split_by_epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SplitBySizeArguments {\n\tstorage: RawTransactionArgument<string>;\n\tsplitSize: RawTransactionArgument<number | bigint>;\n}\nexport interface SplitBySizeOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SplitBySizeArguments\n\t\t| [storage: RawTransactionArgument<string>, splitSize: RawTransactionArgument<number | bigint>];\n}\n/**\n * Splits the storage object into two based on `split_size`.\n *\n * `storage` is modified to cover `split_size` and a new object covering\n * `storage.storage_size - split_size` is created.\n */\nexport function splitBySize(options: SplitBySizeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null, 'u64'] satisfies (string | null)[];\n\tconst parameterNames = ['storage', 'splitSize'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'split_by_size',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface FusePeriodsArguments {\n\tfirst: RawTransactionArgument<string>;\n\tsecond: RawTransactionArgument<string>;\n}\nexport interface FusePeriodsOptions {\n\tpackage?: string;\n\targuments:\n\t\t| FusePeriodsArguments\n\t\t| [first: RawTransactionArgument<string>, second: RawTransactionArgument<string>];\n}\n/** Fuse two storage objects that cover adjacent periods with the same storage size. */\nexport function fusePeriods(options: FusePeriodsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null, null] satisfies (string | null)[];\n\tconst parameterNames = ['first', 'second'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'fuse_periods',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface FuseAmountArguments {\n\tfirst: RawTransactionArgument<string>;\n\tsecond: RawTransactionArgument<string>;\n}\nexport interface FuseAmountOptions {\n\tpackage?: string;\n\targuments:\n\t\t| FuseAmountArguments\n\t\t| [first: RawTransactionArgument<string>, second: RawTransactionArgument<string>];\n}\n/** Fuse two storage objects that cover the same period. */\nexport function fuseAmount(options: FuseAmountOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null, null] satisfies (string | null)[];\n\tconst parameterNames = ['first', 'second'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'fuse_amount',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface FuseArguments {\n\tfirst: RawTransactionArgument<string>;\n\tsecond: RawTransactionArgument<string>;\n}\nexport interface FuseOptions {\n\tpackage?: string;\n\targuments:\n\t\t| FuseArguments\n\t\t| [first: RawTransactionArgument<string>, second: RawTransactionArgument<string>];\n}\n/**\n * Fuse two storage objects that either cover the same period or adjacent periods\n * with the same storage size.\n */\nexport function fuse(options: FuseOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null, null] satisfies (string | null)[];\n\tconst parameterNames = ['first', 'second'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'fuse',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface DestroyArguments {\n\tstorage: RawTransactionArgument<string>;\n}\nexport interface DestroyOptions {\n\tpackage?: string;\n\targuments: DestroyArguments | [storage: RawTransactionArgument<string>];\n}\n/** Destructor for [Storage] objects. */\nexport function destroy(options: DestroyOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [null] satisfies (string | null)[];\n\tconst parameterNames = ['storage'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'destroy',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n"],"mappings":";;;;;;;AAMA,MAAM,cAAc;AACpB,MAAa,UAAU,IAAI,WAAW;CACrC,MAAM,GAAG,YAAY;CACrB,QAAQ;EACP,IAAI,IAAI;EACR,aAAa,IAAI,KAAK;EACtB,WAAW,IAAI,KAAK;EACpB,cAAc,IAAI,KAAK;EACvB;CACD,CAAC"}