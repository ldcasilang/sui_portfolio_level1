{"version":3,"file":"index.mjs","names":["val"],"sources":["../../../src/contracts/utils/index.ts"],"sourcesContent":["import {\n\tbcs,\n\tBcsType,\n\tTypeTag,\n\tTypeTagSerializer,\n\tBcsStruct,\n\tBcsEnum,\n\tBcsTuple,\n} from '@mysten/sui/bcs';\nimport { normalizeSuiAddress } from '@mysten/sui/utils';\nimport { TransactionArgument, isArgument } from '@mysten/sui/transactions';\nimport { ClientWithCoreApi, SuiClientTypes } from '@mysten/sui/client';\n\nconst MOVE_STDLIB_ADDRESS = normalizeSuiAddress('0x1');\nconst SUI_FRAMEWORK_ADDRESS = normalizeSuiAddress('0x2');\n\nexport type RawTransactionArgument<T> = T | TransactionArgument;\n\nexport interface GetOptions<\n\tInclude extends Omit<SuiClientTypes.ObjectInclude, 'content'> = {},\n> extends SuiClientTypes.GetObjectOptions<Include> {\n\tclient: ClientWithCoreApi;\n}\n\nexport interface GetManyOptions<\n\tInclude extends Omit<SuiClientTypes.ObjectInclude, 'content'> = {},\n> extends SuiClientTypes.GetObjectsOptions<Include> {\n\tclient: ClientWithCoreApi;\n}\n\nexport function getPureBcsSchema(typeTag: string | TypeTag): BcsType<any> | null {\n\tconst parsedTag = typeof typeTag === 'string' ? TypeTagSerializer.parseFromStr(typeTag) : typeTag;\n\n\tif ('u8' in parsedTag) {\n\t\treturn bcs.U8;\n\t} else if ('u16' in parsedTag) {\n\t\treturn bcs.U16;\n\t} else if ('u32' in parsedTag) {\n\t\treturn bcs.U32;\n\t} else if ('u64' in parsedTag) {\n\t\treturn bcs.U64;\n\t} else if ('u128' in parsedTag) {\n\t\treturn bcs.U128;\n\t} else if ('u256' in parsedTag) {\n\t\treturn bcs.U256;\n\t} else if ('address' in parsedTag) {\n\t\treturn bcs.Address;\n\t} else if ('bool' in parsedTag) {\n\t\treturn bcs.Bool;\n\t} else if ('vector' in parsedTag) {\n\t\tconst type = getPureBcsSchema(parsedTag.vector);\n\t\treturn type ? bcs.vector(type) : null;\n\t} else if ('struct' in parsedTag) {\n\t\tconst structTag = parsedTag.struct;\n\t\tconst pkg = normalizeSuiAddress(structTag.address);\n\n\t\tif (pkg === MOVE_STDLIB_ADDRESS) {\n\t\t\tif (\n\t\t\t\t(structTag.module === 'ascii' || structTag.module === 'string') &&\n\t\t\t\tstructTag.name === 'String'\n\t\t\t) {\n\t\t\t\treturn bcs.String;\n\t\t\t}\n\n\t\t\tif (structTag.module === 'option' && structTag.name === 'Option') {\n\t\t\t\tconst type = getPureBcsSchema(structTag.typeParams[0]);\n\t\t\t\treturn type ? bcs.option(type) : null;\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\tpkg === SUI_FRAMEWORK_ADDRESS &&\n\t\t\tstructTag.module === 'object' &&\n\t\t\t(structTag.name === 'ID' || structTag.name === 'UID')\n\t\t) {\n\t\t\treturn bcs.Address;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nexport function normalizeMoveArguments(\n\targs: unknown[] | object,\n\targTypes: readonly (string | null)[],\n\tparameterNames?: string[],\n) {\n\tconst argLen = Array.isArray(args) ? args.length : Object.keys(args).length;\n\tif (parameterNames && argLen !== parameterNames.length) {\n\t\tthrow new Error(\n\t\t\t`Invalid number of arguments, expected ${parameterNames.length}, got ${argLen}`,\n\t\t);\n\t}\n\n\tconst normalizedArgs: TransactionArgument[] = [];\n\n\tlet index = 0;\n\tfor (const [i, argType] of argTypes.entries()) {\n\t\tif (argType === '0x2::clock::Clock') {\n\t\t\tnormalizedArgs.push((tx) => tx.object.clock());\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (argType === '0x2::random::Random') {\n\t\t\tnormalizedArgs.push((tx) => tx.object.random());\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (argType === '0x2::deny_list::DenyList') {\n\t\t\tnormalizedArgs.push((tx) => tx.object.denyList());\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (argType === '0x3::sui_system::SuiSystemState') {\n\t\t\tnormalizedArgs.push((tx) => tx.object.system());\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet arg;\n\t\tif (Array.isArray(args)) {\n\t\t\tif (index >= args.length) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Invalid number of arguments, expected at least ${index + 1}, got ${args.length}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\targ = args[index];\n\t\t} else {\n\t\t\tif (!parameterNames) {\n\t\t\t\tthrow new Error(`Expected arguments to be passed as an array`);\n\t\t\t}\n\t\t\tconst name = parameterNames[index];\n\t\t\targ = args[name as keyof typeof args];\n\n\t\t\tif (arg === undefined) {\n\t\t\t\tthrow new Error(`Parameter ${name} is required`);\n\t\t\t}\n\t\t}\n\n\t\tindex += 1;\n\n\t\tif (typeof arg === 'function' || isArgument(arg)) {\n\t\t\tnormalizedArgs.push(arg as TransactionArgument);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst type = argTypes[i];\n\t\tconst bcsType = type === null ? null : getPureBcsSchema(type);\n\n\t\tif (bcsType) {\n\t\t\tconst bytes = bcsType.serialize(arg as never);\n\t\t\tnormalizedArgs.push((tx) => tx.pure(bytes));\n\t\t\tcontinue;\n\t\t} else if (typeof arg === 'string') {\n\t\t\tnormalizedArgs.push((tx) => tx.object(arg));\n\t\t\tcontinue;\n\t\t}\n\n\t\tthrow new Error(`Invalid argument ${stringify(arg)} for type ${type}`);\n\t}\n\n\treturn normalizedArgs;\n}\n\nexport class MoveStruct<\n\tT extends Record<string, BcsType<any>>,\n\tconst Name extends string = string,\n> extends BcsStruct<T, Name> {\n\tasync get<Include extends Omit<SuiClientTypes.ObjectInclude, 'content' | 'json'> = {}>({\n\t\tobjectId,\n\t\t...options\n\t}: GetOptions<Include>): Promise<\n\t\tSuiClientTypes.Object<Include & { content: true; json: true }> & {\n\t\t\tjson: BcsStruct<T>['$inferType'];\n\t\t}\n\t> {\n\t\tconst [res] = await this.getMany<Include>({\n\t\t\t...options,\n\t\t\tobjectIds: [objectId],\n\t\t});\n\n\t\treturn res;\n\t}\n\n\tasync getMany<Include extends Omit<SuiClientTypes.ObjectInclude, 'content' | 'json'> = {}>({\n\t\tclient,\n\t\t...options\n\t}: GetManyOptions<Include>): Promise<\n\t\tArray<\n\t\t\tSuiClientTypes.Object<Include & { content: true; json: true }> & {\n\t\t\t\tjson: BcsStruct<T>['$inferType'];\n\t\t\t}\n\t\t>\n\t> {\n\t\tconst response = (await client.core.getObjects({\n\t\t\t...options,\n\t\t\tinclude: {\n\t\t\t\t...options.include,\n\t\t\t\tcontent: true,\n\t\t\t},\n\t\t})) as SuiClientTypes.GetObjectsResponse<Include & { content: true }>;\n\n\t\treturn response.objects.map((obj) => {\n\t\t\tif (obj instanceof Error) {\n\t\t\t\tthrow obj;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t...obj,\n\t\t\t\tjson: this.parse(obj.content),\n\t\t\t};\n\t\t});\n\t}\n}\n\nexport class MoveEnum<\n\tT extends Record<string, BcsType<any> | null>,\n\tconst Name extends string,\n> extends BcsEnum<T, Name> {}\n\nexport class MoveTuple<\n\tT extends readonly BcsType<any>[],\n\tconst Name extends string,\n> extends BcsTuple<T, Name> {}\n\nfunction stringify(val: unknown) {\n\tif (typeof val === 'object') {\n\t\treturn JSON.stringify(val, (val: unknown) => val);\n\t}\n\tif (typeof val === 'bigint') {\n\t\treturn val.toString();\n\t}\n\n\treturn val;\n}\n"],"mappings":"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"}