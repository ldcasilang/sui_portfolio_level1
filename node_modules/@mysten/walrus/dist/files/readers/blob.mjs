import { SliverData } from "../../utils/bcs.mjs";
import { getSizes, getSourceSymbols } from "../../utils/index.mjs";
import { QuiltReader } from "./quilt.mjs";
import { ClientCache } from "@mysten/sui/client";

//#region src/files/readers/blob.ts
var BlobReader = class {
	#cache = new ClientCache();
	#client;
	#secondarySlivers = /* @__PURE__ */ new Map();
	#numShards;
	constructor({ client, blobId, numShards }) {
		this.hasStartedLoadingFullBlob = false;
		this.#client = client;
		this.blobId = blobId;
		this.#numShards = numShards;
	}
	async getIdentifier() {
		return null;
	}
	async getTags() {
		return {};
	}
	getQuiltReader() {
		return new QuiltReader({ blob: this });
	}
	async getBytes() {
		return this.#cache.read(["getBytes"], async () => {
			this.hasStartedLoadingFullBlob = true;
			try {
				return await this.#client.readBlob({ blobId: this.blobId });
			} catch (error) {
				this.hasStartedLoadingFullBlob = false;
				throw error;
			}
		});
	}
	getMetadata() {
		return this.#cache.read(["getMetadata"], () => this.#client.getBlobMetadata({ blobId: this.blobId }));
	}
	async getColumnSize() {
		return this.#cache.read(["getColumnSize"], async () => {
			const loadingSlivers = [...this.#secondarySlivers.values()];
			if (loadingSlivers.length > 0) {
				const sliver = await Promise.any(loadingSlivers).catch(() => null);
				if (sliver) return sliver.length;
			}
			if (this.hasStartedLoadingFullBlob) {
				const { columnSize: columnSize$1 } = getSizes((await this.getBytes()).length, this.#numShards);
				return columnSize$1;
			}
			const metadata = await this.getMetadata();
			const { columnSize } = getSizes(Number(metadata.metadata.V1.unencoded_length), this.#numShards);
			return columnSize;
		});
	}
	async getSymbolSize() {
		const columnSize = await this.getColumnSize();
		const { primarySymbols } = getSourceSymbols(this.#numShards);
		if (columnSize % primarySymbols !== 0) throw new Error("column size should be divisible by primary symbols");
		return columnSize / primarySymbols;
	}
	async getRowSize() {
		const symbolSize = await this.getSymbolSize();
		const { secondarySymbols } = getSourceSymbols(this.#numShards);
		return symbolSize * secondarySymbols;
	}
	async getSecondarySliver({ sliverIndex, signal }) {
		if (this.#secondarySlivers.has(sliverIndex)) return this.#secondarySlivers.get(sliverIndex);
		const sliverPromise = this.#client.getSecondarySliver({
			blobId: this.blobId,
			index: sliverIndex,
			signal
		}).then((sliver) => SliverData.parse(sliver).symbols.data);
		this.#secondarySlivers.set(sliverIndex, sliverPromise);
		try {
			const sliver = await sliverPromise;
			this.#secondarySlivers.set(sliverIndex, sliver);
			return sliver;
		} catch (error) {
			this.#secondarySlivers.delete(sliverIndex);
			throw error;
		}
	}
};

//#endregion
export { BlobReader };
//# sourceMappingURL=blob.mjs.map