import { WalrusFile } from "./file.mjs";
import { ClientCache } from "@mysten/sui/client";

//#region src/files/blob.ts
var WalrusBlob = class {
	#reader;
	#client;
	#cache = new ClientCache();
	constructor({ reader, client }) {
		this.#reader = reader;
		this.#client = client;
	}
	asFile() {
		return new WalrusFile({ reader: this.#reader });
	}
	async blobId() {
		return this.#reader.blobId;
	}
	async files(filters = {}) {
		const quiltReader = await this.#reader.getQuiltReader();
		const index = await quiltReader.readIndex();
		const files = [];
		for (const patch of index) {
			if (filters.ids && !filters.ids.includes(patch.patchId)) continue;
			if (filters.identifiers && !filters.identifiers.includes(patch.identifier)) continue;
			if (filters.tags && !filters.tags.some((tags) => Object.entries(tags).every(([tagName, tagValue]) => patch.tags[tagName] === tagValue))) continue;
			files.push(new WalrusFile({ reader: quiltReader.readerForPatchId(patch.patchId) }));
		}
		return files;
	}
	async #blobStatus() {
		return this.#cache.read(["blobStatus", this.#reader.blobId], () => this.#client.getVerifiedBlobStatus({ blobId: this.#reader.blobId }));
	}
	async exists() {
		const status = await this.#blobStatus();
		return status.type === "permanent" || status.type === "deletable";
	}
	async storedUntil() {
		const status = await this.#blobStatus();
		if (status.type === "permanent") return status.endEpoch;
		return null;
	}
};

//#endregion
export { WalrusBlob };
//# sourceMappingURL=blob.mjs.map