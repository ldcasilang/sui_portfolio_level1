{"version":3,"file":"client.mjs","names":["#retryOnPossibleEpochChange","#internalReadBlob","#packageConfig","#wasmUrl","#uploadRelayConfig","#uploadRelayClient","#suiClient","#storageNodeClient","#objectLoader","#cache","#getPackageId","#wasmBindings","#getReadCommittee","#blobMetadataConcurrencyLimit","#getActiveCommittee","#getNodeByShardIndex","#getCertificationEpoch","#readCommittee","#forceGetReadCommittee","#getCommittee","#storageCostFromEncodedSize","#getWalrusPackageId","#withWal","tx","#walType","#executeTransaction","#writeBlobAttributesForRef","#loadTipConfig","#getCreatedBlob","metadata._new","#stakingPool","meta"],"sources":["../src/client.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { InferBcsType } from '@mysten/bcs';\nimport { bcs } from '@mysten/bcs';\nimport type { Signer } from '@mysten/sui/cryptography';\nimport type { ClientCache, ClientWithCoreApi } from '@mysten/sui/client';\nimport type { TransactionObjectArgument, TransactionResult } from '@mysten/sui/transactions';\nimport { coinWithBalance, Transaction } from '@mysten/sui/transactions';\nimport { normalizeStructTag, parseStructTag } from '@mysten/sui/utils';\n\nimport {\n\tMAINNET_WALRUS_PACKAGE_CONFIG,\n\tstatusLifecycleRank,\n\tTESTNET_WALRUS_PACKAGE_CONFIG,\n} from './constants.js';\nimport {\n\taddMetadata,\n\tBlob,\n\tinsertOrUpdateMetadataPair,\n\tremoveMetadataPair,\n} from './contracts/walrus/blob.js';\nimport type { Committee } from './contracts/walrus/committee.js';\nimport * as metadata from './contracts/walrus/metadata.js';\nimport { StakingInnerV1 } from './contracts/walrus/staking_inner.js';\nimport { StakingPool } from './contracts/walrus/staking_pool.js';\nimport { Staking } from './contracts/walrus/staking.js';\nimport { Storage } from './contracts/walrus/storage_resource.js';\nimport { SystemStateInnerV1 } from './contracts/walrus/system_state_inner.js';\nimport {\n\tcertifyBlob,\n\tdeleteBlob,\n\textendBlob,\n\tregisterBlob,\n\treserveSpace,\n\tSystem,\n} from './contracts/walrus/system.js';\nimport {\n\tBehindCurrentEpochError,\n\tBlobBlockedError,\n\tBlobNotCertifiedError,\n\tInconsistentBlobError,\n\tNoBlobMetadataReceivedError,\n\tNoBlobStatusReceivedError,\n\tNotEnoughBlobConfirmationsError,\n\tNotEnoughSliversReceivedError,\n\tNoVerifiedBlobStatusReceivedError,\n\tRetryableWalrusClientError,\n\tWalrusClientError,\n} from './error.js';\nimport { StorageNodeClient } from './storage-node/client.js';\nimport {\n\tBlobNotRegisteredError,\n\tLegallyUnavailableError,\n\tNotFoundError,\n\tUserAbortError,\n} from './storage-node/error.js';\nimport type { BlobMetadataWithId, BlobStatus, GetSliverResponse } from './storage-node/types.js';\nimport type {\n\tCertifyBlobOptions,\n\tCommitteeInfo,\n\tComputeBlobMetadataOptions,\n\tDeleteBlobOptions,\n\tEncodingType,\n\tExtendBlobOptions,\n\tUploadRelayConfig,\n\tGetBlobMetadataOptions,\n\tGetCertificationEpochOptions,\n\tGetSecondarySliverOptions,\n\tGetSliversOptions,\n\tGetStorageConfirmationOptions,\n\tGetVerifiedBlobStatusOptions,\n\tProtocolMessageCertificate,\n\tReadBlobOptions,\n\tRegisterBlobOptions,\n\tSliversForNode,\n\tStorageNode,\n\tStorageWithSizeOptions,\n\tWalrusClientConfig,\n\tWalrusPackageConfig,\n\tWriteBlobAttributesOptions,\n\tWriteBlobOptions,\n\tWriteBlobToUploadRelayOptions,\n\tWriteEncodedBlobOptions,\n\tWriteEncodedBlobToNodesOptions,\n\tWriteMetadataOptions,\n\tWriteQuiltOptions,\n\tWriteSliverOptions,\n\tWriteSliversToNodeOptions,\n\tWriteFilesOptions,\n\tWriteFilesFlowOptions,\n\tWriteFilesFlow,\n\tWriteFilesFlowRegisterOptions,\n\tWriteFilesFlowUploadOptions,\n\tWriteBlobFlow,\n\tWriteBlobFlowOptions,\n\tWriteBlobFlowRegisterOptions,\n\tWriteBlobFlowUploadOptions,\n\tWalrusOptions,\n} from './types.js';\nimport { blobIdToInt, IntentType, StorageConfirmation } from './utils/bcs.js';\nimport {\n\tencodedBlobLength,\n\tgetShardIndicesByNodeId,\n\tgetSourceSymbols,\n\tisAboveValidity,\n\tisQuorum,\n\tsignersToBitmap,\n\tsliverPairIndexFromSecondarySliverIndex,\n\tstorageUnitsFromSize,\n\ttoPairIndex,\n\ttoShardIndex,\n} from './utils/index.js';\nimport { SuiObjectDataLoader } from './utils/object-loader.js';\nimport { shuffle, weightedShuffle } from './utils/randomness.js';\nimport { getWasmBindings } from './wasm.js';\nimport { chunk } from '@mysten/utils';\nimport { UploadRelayClient } from './upload-relay/client.js';\nimport { encodeQuilt, encodeQuiltPatchId, parseWalrusId } from './utils/quilts.js';\nimport { BlobReader } from './files/readers/blob.js';\nimport { WalrusBlob } from './files/blob.js';\nimport { WalrusFile } from './files/file.js';\nimport { QuiltFileReader } from './files/readers/quilt-file.js';\nimport { QuiltReader } from './files/readers/quilt.js';\nimport { retry } from './utils/retry.js';\n\nexport function walrus<const Name = 'walrus'>({\n\tpackageConfig,\n\tname = 'walrus' as Name,\n\t...options\n}: WalrusOptions<Name> = {}) {\n\treturn {\n\t\tname,\n\t\tregister: (client: ClientWithCoreApi) => {\n\t\t\tconst walrusNetwork = client.network;\n\n\t\t\tif (walrusNetwork !== 'mainnet' && walrusNetwork !== 'testnet') {\n\t\t\t\tthrow new WalrusClientError('Walrus client only supports mainnet and testnet');\n\t\t\t}\n\n\t\t\treturn new WalrusClient(\n\t\t\t\tpackageConfig\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tpackageConfig,\n\t\t\t\t\t\t\tsuiClient: client,\n\t\t\t\t\t\t\t...options,\n\t\t\t\t\t\t}\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tnetwork: walrusNetwork as 'mainnet' | 'testnet',\n\t\t\t\t\t\t\tsuiClient: client,\n\t\t\t\t\t\t\t...options,\n\t\t\t\t\t\t},\n\t\t\t);\n\t\t},\n\t};\n}\n\nexport class WalrusClient {\n\t#storageNodeClient: StorageNodeClient;\n\t#wasmUrl: string | undefined;\n\n\t#packageConfig: WalrusPackageConfig;\n\t#suiClient: ClientWithCoreApi;\n\t#objectLoader: SuiObjectDataLoader;\n\n\t#blobMetadataConcurrencyLimit = 10;\n\t#readCommittee?: CommitteeInfo | Promise<CommitteeInfo> | null;\n\n\t#cache: ClientCache;\n\n\t#uploadRelayConfig: UploadRelayConfig | null = null;\n\t#uploadRelayClient: UploadRelayClient | null = null;\n\n\tconstructor(config: WalrusClientConfig) {\n\t\tif (config.network && !config.packageConfig) {\n\t\t\tconst network = config.network;\n\t\t\tswitch (network) {\n\t\t\t\tcase 'testnet':\n\t\t\t\t\tthis.#packageConfig = TESTNET_WALRUS_PACKAGE_CONFIG;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'mainnet':\n\t\t\t\t\tthis.#packageConfig = MAINNET_WALRUS_PACKAGE_CONFIG;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new WalrusClientError(`Unsupported network: ${network}`);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.#packageConfig = config.packageConfig!;\n\t\t}\n\n\t\tthis.#wasmUrl = config.wasmUrl;\n\t\tthis.#uploadRelayConfig = config.uploadRelay ?? null;\n\t\tif (this.#uploadRelayConfig) {\n\t\t\tthis.#uploadRelayClient = new UploadRelayClient(this.#uploadRelayConfig);\n\t\t}\n\n\t\tthis.#suiClient = config.suiClient;\n\n\t\tthis.#storageNodeClient = new StorageNodeClient(config.storageNodeClientOptions);\n\t\tthis.#objectLoader = new SuiObjectDataLoader(this.#suiClient);\n\t\tthis.#cache = this.#suiClient.cache.scope('@mysten/walrus');\n\t}\n\n\t/** The Move type for a WAL coin */\n\t#walType() {\n\t\treturn this.#cache.read(['walType'], async () => {\n\t\t\tconst stakeWithPool = await this.#suiClient.core.getMoveFunction({\n\t\t\t\tpackageId: await this.#getPackageId(),\n\t\t\t\tmoduleName: 'staking',\n\t\t\t\tname: 'stake_with_pool',\n\t\t\t});\n\n\t\t\tconst toStake = stakeWithPool.function.parameters[1];\n\t\t\tconst toStakeCoin = toStake.body.$kind === 'datatype' ? toStake.body.datatype : null;\n\t\t\tconst toStakeCoinType =\n\t\t\t\ttoStakeCoin?.typeParameters[0]?.$kind === 'datatype' ? toStakeCoin.typeParameters[0] : null;\n\n\t\t\tif (toStakeCoinType?.$kind !== 'datatype') {\n\t\t\t\tthrow new WalrusClientError('WAL type not found');\n\t\t\t}\n\n\t\t\treturn normalizeStructTag(toStakeCoinType.datatype.typeName);\n\t\t});\n\t}\n\n\t#getPackageId() {\n\t\treturn this.#cache.read(['getPackageId'], async () => {\n\t\t\tconst system = await this.#objectLoader.load(this.#packageConfig.systemObjectId);\n\t\t\treturn parseStructTag(system.type!).address;\n\t\t});\n\t}\n\n\t/** The Move type for a Blob object */\n\tgetBlobType() {\n\t\treturn this.#cache.read(['getBlobType'], async () => {\n\t\t\treturn `${await this.#getPackageId()}::blob::Blob`;\n\t\t});\n\t}\n\n\t#getWalrusPackageId() {\n\t\treturn this.#cache.read(['getSystemPackageId'], async () => {\n\t\t\tconst { package_id } = await this.systemObject();\n\t\t\treturn package_id;\n\t\t});\n\t}\n\n\t#wasmBindings() {\n\t\treturn this.#cache.read(['wasmBindings'], async () => {\n\t\t\treturn getWasmBindings(this.#wasmUrl);\n\t\t});\n\t}\n\n\t/** The cached system object for the walrus package */\n\tsystemObject() {\n\t\treturn this.#objectLoader.load(this.#packageConfig.systemObjectId, System);\n\t}\n\n\t/** The cached staking pool object for the walrus package */\n\tstakingObject() {\n\t\treturn this.#objectLoader.load(this.#packageConfig.stakingPoolId, Staking);\n\t}\n\n\t/** The system state for the current version of walrus contract  */\n\tasync systemState() {\n\t\tconst systemState = await this.#objectLoader.loadFieldObject(\n\t\t\tthis.#packageConfig.systemObjectId,\n\t\t\t{ type: 'u64', value: (await this.systemObject()).version },\n\t\t\tSystemStateInnerV1,\n\t\t);\n\n\t\treturn systemState;\n\t}\n\n\t/** The staking state for the current version of walrus contract */\n\tasync stakingState() {\n\t\treturn this.#objectLoader.loadFieldObject(\n\t\t\tthis.#packageConfig.stakingPoolId,\n\t\t\t{\n\t\t\t\ttype: 'u64',\n\t\t\t\tvalue: (await this.stakingObject()).version,\n\t\t\t},\n\t\t\tStakingInnerV1,\n\t\t);\n\t}\n\n\t/** Read a blob from the storage nodes */\n\treadBlob = this.#retryOnPossibleEpochChange(this.#internalReadBlob);\n\n\tasync #internalReadBlob({ blobId, signal }: ReadBlobOptions) {\n\t\tconst systemState = await this.systemState();\n\t\tconst numShards = systemState.committee.n_shards;\n\n\t\tconst blobMetadata = await this.getBlobMetadata({ blobId, signal });\n\n\t\tconst slivers = await this.getSlivers({ blobId, signal });\n\n\t\tconst bindings = await this.#wasmBindings();\n\n\t\tconst blobBytes = bindings.decodePrimarySlivers(\n\t\t\tblobId,\n\t\t\tnumShards,\n\t\t\tblobMetadata.metadata.V1.unencoded_length,\n\t\t\tslivers,\n\t\t);\n\n\t\tconst reconstructedBlobMetadata = bindings.computeMetadata(\n\t\t\tsystemState.committee.n_shards,\n\t\t\tblobBytes,\n\t\t);\n\n\t\tif (reconstructedBlobMetadata.blobId !== blobId) {\n\t\t\tthrow new InconsistentBlobError('The specified blob was encoded incorrectly.');\n\t\t}\n\n\t\treturn blobBytes;\n\t}\n\n\tasync computeBlobMetadata({ bytes, numShards }: ComputeBlobMetadataOptions) {\n\t\tlet shardCount: number | undefined;\n\t\tif (typeof numShards === 'number') {\n\t\t\tshardCount = numShards;\n\t\t} else {\n\t\t\tconst systemState = await this.systemState();\n\t\t\tshardCount = systemState.committee.n_shards;\n\t\t}\n\n\t\tconst bindings = await this.#wasmBindings();\n\t\tconst { blobId, rootHash, unencodedLength, encodingType } = bindings.computeMetadata(\n\t\t\tshardCount,\n\t\t\tbytes,\n\t\t);\n\t\tlet sha256Hash: Promise<Uint8Array> | undefined;\n\t\tconst nonce = crypto.getRandomValues(new Uint8Array(32));\n\n\t\treturn {\n\t\t\trootHash,\n\t\t\tblobId,\n\t\t\tmetadata: {\n\t\t\t\tencodingType,\n\t\t\t\tunencodedLength,\n\t\t\t},\n\t\t\tnonce,\n\t\t\tblobDigest: () => {\n\t\t\t\tif (!sha256Hash) {\n\t\t\t\t\tsha256Hash = crypto.subtle\n\t\t\t\t\t\t.digest('SHA-256', bytes as BufferSource)\n\t\t\t\t\t\t.then((hash) => new Uint8Array(hash));\n\t\t\t\t}\n\n\t\t\t\treturn sha256Hash;\n\t\t\t},\n\t\t};\n\t}\n\n\tasync getBlobMetadata({ blobId, signal }: GetBlobMetadataOptions) {\n\t\tconst committee = await this.#getReadCommittee({ blobId, signal });\n\t\tconst randomizedNodes = shuffle(committee.nodes);\n\n\t\tconst stakingState = await this.stakingState();\n\t\tconst numShards = stakingState.n_shards;\n\n\t\tlet numNotFoundWeight = 0;\n\t\tlet numBlockedWeight = 0;\n\t\tlet totalErrorCount = 0;\n\t\tconst controller = new AbortController();\n\n\t\tconst metadataExecutors = randomizedNodes.map((node) => async () => {\n\t\t\ttry {\n\t\t\t\treturn await this.#storageNodeClient.getBlobMetadata(\n\t\t\t\t\t{ blobId },\n\t\t\t\t\t{\n\t\t\t\t\t\tnodeUrl: node.networkUrl,\n\t\t\t\t\t\tsignal: signal ? AbortSignal.any([controller.signal, signal]) : controller.signal,\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof NotFoundError) {\n\t\t\t\t\tnumNotFoundWeight += node.shardIndices.length;\n\t\t\t\t} else if (error instanceof LegallyUnavailableError) {\n\t\t\t\t\tnumBlockedWeight += node.shardIndices.length;\n\t\t\t\t}\n\n\t\t\t\ttotalErrorCount += 1;\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t});\n\n\t\ttry {\n\t\t\tconst attemptGetMetadata = metadataExecutors.shift()!;\n\t\t\treturn await attemptGetMetadata();\n\t\t} catch {\n\t\t\tconst chunkSize = Math.floor(metadataExecutors.length / this.#blobMetadataConcurrencyLimit);\n\t\t\tconst chunkedExecutors = chunk(metadataExecutors, chunkSize);\n\n\t\t\treturn await new Promise<BlobMetadataWithId>((resolve, reject) => {\n\t\t\t\tchunkedExecutors.forEach(async (executors) => {\n\t\t\t\t\tfor (const executor of executors) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst result = await executor();\n\t\t\t\t\t\t\tcontroller.abort('Blob metadata successfully retrieved.');\n\t\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tif (error instanceof UserAbortError) {\n\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t} else if (isQuorum(numBlockedWeight + numNotFoundWeight, numShards)) {\n\t\t\t\t\t\t\t\tconst abortError =\n\t\t\t\t\t\t\t\t\tnumNotFoundWeight > numBlockedWeight\n\t\t\t\t\t\t\t\t\t\t? new BlobNotCertifiedError(`The specified blob ${blobId} is not certified.`)\n\t\t\t\t\t\t\t\t\t\t: new BlobBlockedError(`The specified blob ${blobId} is blocked.`);\n\n\t\t\t\t\t\t\t\tcontroller.abort(abortError);\n\t\t\t\t\t\t\t\treject(abortError);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (totalErrorCount === metadataExecutors.length) {\n\t\t\t\t\t\t\t\treject(\n\t\t\t\t\t\t\t\t\tnew NoBlobMetadataReceivedError(\n\t\t\t\t\t\t\t\t\t\t'No valid blob metadata could be retrieved from any storage node.',\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n\n\tgetSecondarySliver = this.#retryOnPossibleEpochChange(this.internalGetSecondarySliver);\n\n\tasync internalGetSecondarySliver({ blobId, index, signal }: GetSecondarySliverOptions) {\n\t\tconst committee = await this.#getActiveCommittee();\n\t\tconst stakingState = await this.stakingState();\n\t\tconst numShards = stakingState.n_shards;\n\t\tconst sliverPairIndex = sliverPairIndexFromSecondarySliverIndex(index, numShards);\n\t\tconst shardIndex = toShardIndex(sliverPairIndex, blobId, numShards);\n\t\tconst node = await this.#getNodeByShardIndex(committee, shardIndex);\n\n\t\tif (!node) {\n\t\t\tthrow new Error(`No node found for shard index ${shardIndex}`);\n\t\t}\n\n\t\tconst sliver = await this.#storageNodeClient.getSliver(\n\t\t\t{ blobId, sliverPairIndex, sliverType: 'secondary' },\n\t\t\t{\n\t\t\t\tnodeUrl: node.networkUrl,\n\t\t\t\tsignal,\n\t\t\t},\n\t\t);\n\n\t\treturn sliver;\n\t}\n\n\tasync getSlivers({ blobId, signal }: GetSliversOptions) {\n\t\tconst committee = await this.#getReadCommittee({ blobId, signal });\n\t\tconst randomizedNodes = weightedShuffle(\n\t\t\tcommittee.nodes.map((node) => ({\n\t\t\t\tvalue: node,\n\t\t\t\tweight: node.shardIndices.length,\n\t\t\t})),\n\t\t);\n\n\t\tconst stakingState = await this.stakingState();\n\t\tconst numShards = stakingState.n_shards;\n\t\tconst { primarySymbols: minSymbols } = getSourceSymbols(numShards);\n\n\t\tconst sliverPairIndices = randomizedNodes.flatMap((node) =>\n\t\t\tnode.shardIndices.map((shardIndex) => ({\n\t\t\t\turl: node.networkUrl,\n\t\t\t\tsliverPairIndex: toPairIndex(shardIndex, blobId, numShards),\n\t\t\t})),\n\t\t);\n\n\t\tconst controller = new AbortController();\n\t\tconst chunkedSliverPairIndices = chunk(sliverPairIndices, minSymbols);\n\t\tconst slivers: GetSliverResponse[] = [];\n\t\tconst failedNodes = new Set<string>();\n\t\tlet numNotFoundWeight = 0;\n\t\tlet numBlockedWeight = 0;\n\t\tlet totalErrorCount = 0;\n\n\t\treturn new Promise<GetSliverResponse[]>((resolve, reject) => {\n\t\t\tchunkedSliverPairIndices[0].forEach(async (_, colIndex) => {\n\t\t\t\tfor (let rowIndex = 0; rowIndex < chunkedSliverPairIndices.length; rowIndex += 1) {\n\t\t\t\t\tconst value = chunkedSliverPairIndices.at(rowIndex)?.at(colIndex);\n\t\t\t\t\tif (!value) break;\n\n\t\t\t\t\tconst { url, sliverPairIndex } = value;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (failedNodes.has(url)) {\n\t\t\t\t\t\t\tthrow new Error(`Skipping node at ${url} due to previous failure.`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst sliver = await this.#storageNodeClient.getSliver(\n\t\t\t\t\t\t\t{ blobId, sliverPairIndex, sliverType: 'primary' },\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnodeUrl: url,\n\t\t\t\t\t\t\t\tsignal: signal ? AbortSignal.any([controller.signal, signal]) : controller.signal,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (slivers.length === minSymbols) {\n\t\t\t\t\t\t\tcontroller.abort('Enough slivers successfully retrieved.');\n\t\t\t\t\t\t\tresolve(slivers);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tslivers.push(sliver);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tif (error instanceof NotFoundError) {\n\t\t\t\t\t\t\tnumNotFoundWeight += 1;\n\t\t\t\t\t\t} else if (error instanceof LegallyUnavailableError) {\n\t\t\t\t\t\t\tnumBlockedWeight += 1;\n\t\t\t\t\t\t} else if (error instanceof UserAbortError) {\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isQuorum(numBlockedWeight + numNotFoundWeight, numShards)) {\n\t\t\t\t\t\t\tconst abortError =\n\t\t\t\t\t\t\t\tnumNotFoundWeight > numBlockedWeight\n\t\t\t\t\t\t\t\t\t? new BlobNotCertifiedError(`The specified blob ${blobId} is not certified.`)\n\t\t\t\t\t\t\t\t\t: new BlobBlockedError(`The specified blob ${blobId} is blocked.`);\n\n\t\t\t\t\t\t\tcontroller.abort(abortError);\n\t\t\t\t\t\t\treject(abortError);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfailedNodes.add(url);\n\t\t\t\t\t\ttotalErrorCount += 1;\n\n\t\t\t\t\t\tconst remainingTasks = sliverPairIndices.length - (slivers.length + totalErrorCount);\n\t\t\t\t\t\tconst tooManyFailures = slivers.length + remainingTasks < minSymbols;\n\n\t\t\t\t\t\tif (tooManyFailures) {\n\t\t\t\t\t\t\tconst abortError = new NotEnoughSliversReceivedError(\n\t\t\t\t\t\t\t\t`Unable to retrieve enough slivers to decode blob ${blobId}.`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontroller.abort(abortError);\n\t\t\t\t\t\t\treject(abortError);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Gets the blob status from multiple storage nodes and returns the latest status that can be verified.\n\t */\n\tasync getVerifiedBlobStatus({ blobId, signal }: GetVerifiedBlobStatusOptions) {\n\t\t// Read from the latest committee because, during epoch change, it is the committee\n\t\t// that will have the most up-to-date information on old and newly certified blobs:\n\t\tconst committee = await this.#getActiveCommittee();\n\t\tconst stakingState = await this.stakingState();\n\t\tconst numShards = stakingState.n_shards;\n\t\tconst controller = new AbortController();\n\n\t\tconst statuses = await new Promise<{ status: BlobStatus; weight: number }[]>(\n\t\t\t(resolve, reject) => {\n\t\t\t\tconst results: { status: BlobStatus; weight: number }[] = [];\n\t\t\t\tlet successWeight = 0;\n\t\t\t\tlet numNotFoundWeight = 0;\n\t\t\t\tlet settledCount = 0;\n\n\t\t\t\tcommittee.nodes.forEach(async (node) => {\n\t\t\t\t\tconst weight = node.shardIndices.length;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst status = await this.#storageNodeClient.getBlobStatus(\n\t\t\t\t\t\t\t{ blobId },\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnodeUrl: node.networkUrl,\n\t\t\t\t\t\t\t\tsignal: signal ? AbortSignal.any([controller.signal, signal]) : controller.signal,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (isQuorum(successWeight, numShards)) {\n\t\t\t\t\t\t\tcontroller.abort('Quorum of blob statuses retrieved successfully.');\n\t\t\t\t\t\t\tresolve(results);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsuccessWeight += weight;\n\t\t\t\t\t\t\tresults.push({ status, weight });\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tif (error instanceof NotFoundError) {\n\t\t\t\t\t\t\tnumNotFoundWeight += weight;\n\t\t\t\t\t\t} else if (error instanceof UserAbortError) {\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isQuorum(numNotFoundWeight, numShards)) {\n\t\t\t\t\t\t\tconst abortError = new BlobNotCertifiedError('The blob does not exist.');\n\t\t\t\t\t\t\tcontroller.abort(abortError);\n\t\t\t\t\t\t\treject(abortError);\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tsettledCount += 1;\n\t\t\t\t\t\tif (settledCount === committee.nodes.length) {\n\t\t\t\t\t\t\treject(\n\t\t\t\t\t\t\t\tnew NoBlobStatusReceivedError(\n\t\t\t\t\t\t\t\t\t'Not enough statuses were retrieved to achieve quorum.',\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t);\n\n\t\tconst aggregatedStatuses = statuses.reduce((accumulator, value) => {\n\t\t\tconst { status, weight } = value;\n\t\t\tconst key = JSON.stringify(status);\n\n\t\t\tconst existing = accumulator.get(key);\n\t\t\tif (existing) {\n\t\t\t\texisting.totalWeight += weight;\n\t\t\t} else {\n\t\t\t\taccumulator.set(key, { status, totalWeight: weight });\n\t\t\t}\n\n\t\t\treturn accumulator;\n\t\t}, new Map<string, { status: BlobStatus; totalWeight: number }>());\n\n\t\tconst uniqueStatuses = [...aggregatedStatuses.values()];\n\t\tconst sortedStatuses = uniqueStatuses.toSorted(\n\t\t\t(a, b) => statusLifecycleRank[b.status.type] - statusLifecycleRank[a.status.type],\n\t\t);\n\n\t\tfor (const value of sortedStatuses) {\n\t\t\t// TODO: We can check the chain via the `event` field as a fallback here.\n\t\t\tif (isAboveValidity(value.totalWeight, numShards)) {\n\t\t\t\treturn value.status;\n\t\t\t}\n\t\t}\n\n\t\tthrow new NoVerifiedBlobStatusReceivedError(\n\t\t\t`The blob status could not be verified for blob ${blobId},`,\n\t\t);\n\t}\n\n\tasync #getCertificationEpoch({ blobId, signal }: GetCertificationEpochOptions) {\n\t\tconst stakingState = await this.stakingState();\n\t\tconst currentEpoch = stakingState.epoch;\n\n\t\tif (stakingState.epoch_state.$kind === 'EpochChangeSync') {\n\t\t\tconst status = await this.getVerifiedBlobStatus({ blobId, signal });\n\t\t\tif (status.type === 'nonexistent' || status.type === 'invalid') {\n\t\t\t\tthrow new BlobNotCertifiedError(`The specified blob ${blobId} is ${status.type}.`);\n\t\t\t}\n\n\t\t\tif (typeof status.initialCertifiedEpoch !== 'number') {\n\t\t\t\tthrow new BlobNotCertifiedError(`The specified blob ${blobId} is not certified.`);\n\t\t\t}\n\n\t\t\tif (status.initialCertifiedEpoch > currentEpoch) {\n\t\t\t\tthrow new BehindCurrentEpochError(\n\t\t\t\t\t`The client is at epoch ${currentEpoch} while the specified blob was certified at epoch ${status.initialCertifiedEpoch}.`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn status.initialCertifiedEpoch;\n\t\t}\n\n\t\treturn currentEpoch;\n\t}\n\n\t/**\n\t * Retrieves the node committee responsible for serving reads.\n\t *\n\t * During an epoch change, reads should be served by the previous committee if the blob was\n\t * certified in an earlier epoch. This ensures that we read from nodes with the most accurate\n\t * information as nodes from the current committee might still be receiving transferred shards\n\t * from the previous committee.\n\t */\n\tasync #getReadCommittee(options: ReadBlobOptions) {\n\t\tif (!this.#readCommittee) {\n\t\t\tthis.#readCommittee = this.#forceGetReadCommittee(options);\n\t\t}\n\t\treturn this.#readCommittee;\n\t}\n\n\tasync #forceGetReadCommittee({ blobId, signal }: ReadBlobOptions) {\n\t\tconst stakingState = await this.stakingState();\n\t\tconst isTransitioning = stakingState.epoch_state.$kind === 'EpochChangeSync';\n\t\tconst certificationEpoch = await this.#getCertificationEpoch({ blobId, signal });\n\n\t\tif (isTransitioning && certificationEpoch < stakingState.epoch) {\n\t\t\treturn await this.#getCommittee(stakingState.previous_committee);\n\t\t}\n\t\treturn await this.#getActiveCommittee();\n\t}\n\n\t/**\n\t * Calculate the cost of storing a blob for a given a size and number of epochs.\n\t */\n\tasync storageCost(size: number, epochs: number) {\n\t\tconst systemState = await this.systemState();\n\t\tconst encodedSize = encodedBlobLength(size, systemState.committee.n_shards);\n\t\treturn this.#storageCostFromEncodedSize(encodedSize, epochs);\n\t}\n\n\tasync #storageCostFromEncodedSize(encodedSize: number, epochs: number) {\n\t\tconst systemState = await this.systemState();\n\t\tconst storageUnits = storageUnitsFromSize(encodedSize);\n\t\tconst storageCost =\n\t\t\tBigInt(storageUnits) * BigInt(systemState.storage_price_per_unit_size) * BigInt(epochs);\n\n\t\tconst writeCost = BigInt(storageUnits) * BigInt(systemState.write_price_per_unit_size);\n\n\t\treturn { storageCost, writeCost, totalCost: storageCost + writeCost };\n\t}\n\n\t/**\n\t * A utility for creating a storage object in a transaction.\n\t *\n\t * @example\n\t * ```ts\n\t * tx.transferObjects([client.createStorage({ size: 1000, epochs: 3 })], owner);\n\t * ```\n\t */\n\tcreateStorage({ size, epochs, walCoin }: StorageWithSizeOptions) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst systemObject = await this.systemObject();\n\t\t\tconst systemState = await this.systemState();\n\t\t\tconst encodedSize = encodedBlobLength(size, systemState.committee.n_shards);\n\t\t\tconst [{ storageCost }, walrusPackageId] = await Promise.all([\n\t\t\t\tthis.storageCost(size, epochs),\n\t\t\t\tthis.#getWalrusPackageId(),\n\t\t\t]);\n\n\t\t\treturn tx.add(\n\t\t\t\tthis.#withWal(storageCost, walCoin ?? null, (coin, tx) => {\n\t\t\t\t\treturn tx.add(\n\t\t\t\t\t\treserveSpace({\n\t\t\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\t\tself: systemObject.id,\n\t\t\t\t\t\t\t\tstorageAmount: encodedSize,\n\t\t\t\t\t\t\t\tepochsAhead: epochs,\n\t\t\t\t\t\t\t\tpayment: coin,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}),\n\t\t\t);\n\t\t};\n\t}\n\n\t#withWal<T extends TransactionResult | void>(\n\t\tamount: bigint,\n\t\tsource: TransactionObjectArgument | null,\n\t\tfn: (coin: TransactionObjectArgument, tx: Transaction) => T | Promise<T>,\n\t) {\n\t\treturn async (tx: Transaction): Promise<T> => {\n\t\t\tconst walType = await this.#walType();\n\t\t\tconst coin = source\n\t\t\t\t? tx.splitCoins(source, [amount])[0]\n\t\t\t\t: tx.add(\n\t\t\t\t\t\tcoinWithBalance({\n\t\t\t\t\t\t\tbalance: amount,\n\t\t\t\t\t\t\ttype: walType,\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\n\t\t\tconst result = await fn(coin, tx);\n\n\t\t\ttx.moveCall({\n\t\t\t\ttarget: '0x2::coin::destroy_zero',\n\t\t\t\ttypeArguments: [walType],\n\t\t\t\targuments: [coin],\n\t\t\t});\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\t/**\n\t * Create a transaction that creates a storage object\n\t *\n\t * @example\n\t * ```ts\n\t * const tx = client.createStorageTransaction({ size: 1000, epochs: 3, owner: signer.toSuiAddress() });\n\t * ```\n\t */\n\tcreateStorageTransaction({\n\t\ttransaction = new Transaction(),\n\t\tsize,\n\t\tepochs,\n\t\towner,\n\t}: StorageWithSizeOptions & {\n\t\ttransaction?: Transaction;\n\t\t/** Address the storage resource should be transferred to */\n\t\towner: string;\n\t}) {\n\t\ttransaction.transferObjects([this.createStorage({ size, epochs })], owner);\n\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Execute a transaction that creates a storage object\n\t *\n\t * @example\n\t * ```ts\n\t * const { digest, storage } = await client.executeCreateStorageTransaction({ size: 1000, epochs: 3, signer });\n\t * ```\n\t */\n\tasync executeCreateStorageTransaction({\n\t\tsigner,\n\t\t...options\n\t}: StorageWithSizeOptions & { transaction?: Transaction; signer: Signer }) {\n\t\tconst transaction = this.createStorageTransaction({\n\t\t\t...options,\n\t\t\towner: options.transaction?.getData().sender ?? signer.toSuiAddress(),\n\t\t});\n\t\tconst blobType = await this.getBlobType();\n\n\t\tconst { digest, effects } = await this.#executeTransaction(\n\t\t\ttransaction,\n\t\t\tsigner,\n\t\t\t'create storage',\n\t\t);\n\n\t\tconst createdObjectIds = effects?.changedObjects\n\t\t\t.filter((object) => object.idOperation === 'Created')\n\t\t\t.map((object) => object.objectId);\n\n\t\tconst createdObjects = await this.#suiClient.core.getObjects({\n\t\t\tobjectIds: createdObjectIds,\n\t\t\tinclude: { content: true },\n\t\t});\n\n\t\tconst suiBlobObject = createdObjects.objects.find(\n\t\t\t(object) => !(object instanceof Error) && object.type === blobType,\n\t\t);\n\n\t\tif (suiBlobObject instanceof Error || !suiBlobObject) {\n\t\t\tthrow new WalrusClientError(\n\t\t\t\t`Storage object not found in transaction effects for transaction (${digest})`,\n\t\t\t);\n\t\t}\n\n\t\treturn {\n\t\t\tdigest,\n\t\t\tstorage: Storage.parse(suiBlobObject.content),\n\t\t};\n\t}\n\n\t/**\n\t * Register a blob in a transaction\n\t *\n\t * @example\n\t * ```ts\n\t * tx.transferObjects([client.registerBlob({ size: 1000, epochs: 3, blobId, rootHash, deletable: true })], owner);\n\t * ```\n\t */\n\tregisterBlob({\n\t\tsize,\n\t\tepochs,\n\t\tblobId,\n\t\trootHash,\n\t\tdeletable,\n\t\twalCoin,\n\t\tattributes,\n\t}: RegisterBlobOptions) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst { writeCost } = await this.storageCost(size, epochs);\n\t\t\tconst walrusPackageId = await this.#getWalrusPackageId();\n\n\t\t\treturn tx.add(\n\t\t\t\tthis.#withWal(writeCost, walCoin ?? null, async (writeCoin, tx) => {\n\t\t\t\t\tconst blob = tx.add(\n\t\t\t\t\t\tregisterBlob({\n\t\t\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\t\tself: tx.object(this.#packageConfig.systemObjectId),\n\t\t\t\t\t\t\t\tstorage: this.createStorage({ size, epochs, walCoin }),\n\t\t\t\t\t\t\t\tblobId: blobIdToInt(blobId),\n\t\t\t\t\t\t\t\trootHash: BigInt(bcs.u256().parse(rootHash)),\n\t\t\t\t\t\t\t\tsize,\n\t\t\t\t\t\t\t\tencodingType: 1,\n\t\t\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\t\t\twritePayment: writeCoin,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\n\t\t\t\t\tif (attributes) {\n\t\t\t\t\t\ttx.add(\n\t\t\t\t\t\t\tthis.#writeBlobAttributesForRef({\n\t\t\t\t\t\t\t\tattributes,\n\t\t\t\t\t\t\t\texistingAttributes: null,\n\t\t\t\t\t\t\t\tblob,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn blob;\n\t\t\t\t}),\n\t\t\t);\n\t\t};\n\t}\n\n\taddAuthPayload({\n\t\tsize,\n\t\tblobDigest,\n\t\tnonce,\n\t}: {\n\t\tsize: number;\n\t\tblobDigest: Uint8Array | (() => Promise<Uint8Array>);\n\t\tnonce: Uint8Array;\n\t}) {\n\t\treturn async (transaction: Transaction) => {\n\t\t\tconst nonceDigest = await crypto.subtle.digest('SHA-256', nonce as BufferSource);\n\t\t\tconst lengthBytes = bcs.u64().serialize(size).toBytes();\n\t\t\tconst digest = typeof blobDigest === 'function' ? await blobDigest() : blobDigest;\n\t\t\tconst authPayload = new Uint8Array(\n\t\t\t\tnonceDigest.byteLength + digest.byteLength + lengthBytes.byteLength,\n\t\t\t);\n\n\t\t\tauthPayload.set(digest, 0);\n\t\t\tauthPayload.set(new Uint8Array(nonceDigest), digest.byteLength);\n\t\t\tauthPayload.set(lengthBytes, nonceDigest.byteLength + digest.byteLength);\n\t\t\ttransaction.pure(authPayload);\n\t\t};\n\t}\n\n\t#loadTipConfig() {\n\t\treturn this.#cache.read(['upload-relay-tip-config'], async () => {\n\t\t\tif (!this.#uploadRelayConfig?.sendTip || !this.#uploadRelayClient) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ('kind' in this.#uploadRelayConfig.sendTip) {\n\t\t\t\treturn this.#uploadRelayConfig.sendTip;\n\t\t\t}\n\n\t\t\tconst tipConfig = await this.#uploadRelayClient.tipConfig();\n\n\t\t\tif (!tipConfig) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t...tipConfig,\n\t\t\t\tmax: this.#uploadRelayConfig.sendTip.max,\n\t\t\t};\n\t\t});\n\t}\n\n\tasync calculateUploadRelayTip(options: { size: number }) {\n\t\tconst systemState = await this.systemState();\n\t\tconst encodedSize = encodedBlobLength(options.size, systemState.committee.n_shards);\n\t\tconst tipConfig = await this.#loadTipConfig();\n\n\t\tif (!tipConfig) {\n\t\t\treturn 0n;\n\t\t}\n\n\t\tconst { max, kind } = tipConfig;\n\n\t\tconst amount =\n\t\t\t'const' in kind\n\t\t\t\t? kind.const\n\t\t\t\t: BigInt(kind.linear.base) +\n\t\t\t\t\tBigInt(kind.linear.perEncodedKib) * ((BigInt(encodedSize) + 1023n) / 1024n); // Compute the ceiling of the division.\n\n\t\tif (max != null && amount > max) {\n\t\t\tthrow new WalrusClientError(\n\t\t\t\t`Tip amount (${amount}) exceeds the maximum allowed tip (${max})`,\n\t\t\t);\n\t\t}\n\n\t\treturn amount;\n\t}\n\n\tsendUploadRelayTip({\n\t\tsize,\n\t\tblobDigest,\n\t\tnonce,\n\t}: {\n\t\tsize: number;\n\t\tblobDigest: Uint8Array | (() => Promise<Uint8Array>);\n\t\tnonce: Uint8Array;\n\t}) {\n\t\treturn async (transaction: Transaction) => {\n\t\t\tconst tipConfig = await this.#loadTipConfig();\n\n\t\t\tif (tipConfig) {\n\t\t\t\ttransaction.add(this.addAuthPayload({ size, blobDigest, nonce }));\n\t\t\t\tconst amount = await this.calculateUploadRelayTip({ size });\n\t\t\t\tconst { address } = tipConfig;\n\t\t\t\ttransaction.transferObjects(\n\t\t\t\t\t[\n\t\t\t\t\t\tcoinWithBalance({\n\t\t\t\t\t\t\tbalance: amount,\n\t\t\t\t\t\t}),\n\t\t\t\t\t],\n\t\t\t\t\taddress,\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Create a transaction that registers a blob\n\t *\n\t * @example\n\t * ```ts\n\t * const tx = client.registerBlobTransaction({ size: 1000, epochs: 3, blobId, rootHash, deletable: true });\n\t * ```\n\t */\n\tregisterBlobTransaction({\n\t\ttransaction = new Transaction(),\n\t\t...options\n\t}: RegisterBlobOptions & {\n\t\ttransaction?: Transaction;\n\t\t/** Address the blob should be transferred to */\n\t\towner: string;\n\t}) {\n\t\tconst registration = transaction.add(this.registerBlob(options));\n\n\t\ttransaction.transferObjects([registration], options.owner);\n\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Execute a transaction that registers a blob\n\t *\n\t * @example\n\t * ```ts\n\t * const { digest, blob } = await client.executeRegisterBlobTransaction({ size: 1000, epochs: 3, signer });\n\t * ```\n\t */\n\tasync executeRegisterBlobTransaction({\n\t\tsigner,\n\t\t...options\n\t}: RegisterBlobOptions & {\n\t\ttransaction?: Transaction;\n\t\tsigner: Signer;\n\t\t/** Address the blob should be transferred to */\n\t\towner?: string;\n\t}): Promise<{\n\t\tblob: (typeof Blob)['$inferType'];\n\t\tdigest: string;\n\t}> {\n\t\tconst transaction = this.registerBlobTransaction({\n\t\t\t...options,\n\t\t\towner: options.owner ?? options.transaction?.getData().sender ?? signer.toSuiAddress(),\n\t\t});\n\t\tconst blobType = await this.getBlobType();\n\t\tconst { digest, effects } = await this.#executeTransaction(\n\t\t\ttransaction,\n\t\t\tsigner,\n\t\t\t'register blob',\n\t\t);\n\n\t\tconst createdObjectIds = effects?.changedObjects\n\t\t\t.filter((object) => object.idOperation === 'Created')\n\t\t\t.map((object) => object.objectId);\n\n\t\tconst createdObjects = await this.#suiClient.core.getObjects({\n\t\t\tobjectIds: createdObjectIds,\n\t\t\tinclude: { content: true },\n\t\t});\n\n\t\tconst suiBlobObject = createdObjects.objects.find(\n\t\t\t(object) => !(object instanceof Error) && object.type === blobType,\n\t\t);\n\n\t\tif (suiBlobObject instanceof Error || !suiBlobObject) {\n\t\t\tthrow new WalrusClientError(\n\t\t\t\t`Blob object not found in transaction effects for transaction (${digest})`,\n\t\t\t);\n\t\t}\n\n\t\treturn {\n\t\t\tdigest,\n\t\t\tblob: Blob.parse(suiBlobObject.content),\n\t\t};\n\t}\n\n\tasync #getCreatedBlob(digest: string) {\n\t\tconst blobType = await this.getBlobType();\n\t\tconst result = await this.#suiClient.core.waitForTransaction({\n\t\t\tdigest,\n\t\t\tinclude: { effects: true },\n\t\t});\n\n\t\tconst tx = result.Transaction ?? result.FailedTransaction;\n\t\tconst createdObjectIds = tx.effects?.changedObjects\n\t\t\t.filter((object: { idOperation: string }) => object.idOperation === 'Created')\n\t\t\t.map((object: { objectId: string }) => object.objectId);\n\n\t\tconst createdObjects = await this.#suiClient.core.getObjects({\n\t\t\tobjectIds: createdObjectIds,\n\t\t\tinclude: { content: true },\n\t\t});\n\n\t\tconst suiBlobObject = createdObjects.objects.find(\n\t\t\t(object) => !(object instanceof Error) && object.type === blobType,\n\t\t);\n\n\t\tif (suiBlobObject instanceof Error || !suiBlobObject) {\n\t\t\tthrow new WalrusClientError(\n\t\t\t\t`Blob object not found in transaction effects for transaction (${digest})`,\n\t\t\t);\n\t\t}\n\n\t\treturn Blob.parse(suiBlobObject.content);\n\t}\n\n\tasync certificateFromConfirmations({\n\t\tconfirmations,\n\t\tblobId,\n\t\tdeletable,\n\t\tblobObjectId,\n\t}: Extract<\n\t\tCertifyBlobOptions,\n\t\t{ confirmations: unknown[] }\n\t>): Promise<ProtocolMessageCertificate> {\n\t\tconst systemState = await this.systemState();\n\t\tconst committee = await this.#getActiveCommittee();\n\n\t\tif (confirmations.length !== systemState.committee.members.length) {\n\t\t\tthrow new WalrusClientError(\n\t\t\t\t'Invalid number of confirmations. Confirmations array must contain an entry for each node',\n\t\t\t);\n\t\t}\n\n\t\tconst confirmationMessage = StorageConfirmation.serialize({\n\t\t\tintent: IntentType.BLOB_CERT_MSG,\n\t\t\tepoch: systemState.committee.epoch,\n\t\t\tmessageContents: {\n\t\t\t\tblobId,\n\t\t\t\tblobType: deletable\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tDeletable: {\n\t\t\t\t\t\t\t\tobjectId: blobObjectId,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tPermanent: null,\n\t\t\t\t\t\t},\n\t\t\t},\n\t\t}).toBase64();\n\n\t\tconst bindings = await this.#wasmBindings();\n\t\tconst verifySignature = bindings.getVerifySignature();\n\n\t\tconst filteredConfirmations = confirmations\n\t\t\t.map((confirmation, index) => {\n\t\t\t\tconst isValid =\n\t\t\t\t\tconfirmation?.serializedMessage === confirmationMessage &&\n\t\t\t\t\tverifySignature(\n\t\t\t\t\t\tconfirmation,\n\t\t\t\t\t\tnew Uint8Array(committee.nodes[index].info.public_key.bytes),\n\t\t\t\t\t);\n\n\t\t\t\treturn isValid\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tindex,\n\t\t\t\t\t\t\t...confirmation,\n\t\t\t\t\t\t}\n\t\t\t\t\t: null;\n\t\t\t})\n\t\t\t.filter((confirmation) => confirmation !== null);\n\n\t\tif (!isQuorum(filteredConfirmations.length, systemState.committee.members.length)) {\n\t\t\tthrow new NotEnoughBlobConfirmationsError(\n\t\t\t\t`Too many invalid confirmations received for blob (${filteredConfirmations.length} of ${systemState.committee.members.length})`,\n\t\t\t);\n\t\t}\n\n\t\treturn bindings.combineSignatures(\n\t\t\tfilteredConfirmations,\n\t\t\tfilteredConfirmations.map(({ index }) => index),\n\t\t);\n\t}\n\n\t/**\n\t * Certify a blob in a transaction\n\t *\n\t * @example\n\t * ```ts\n\t * tx.add(client.certifyBlob({ blobId, blobObjectId, confirmations }));\n\t * ```\n\t */\n\tcertifyBlob({ blobId, blobObjectId, confirmations, certificate, deletable }: CertifyBlobOptions) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst systemState = await this.systemState();\n\t\t\tconst combinedSignature =\n\t\t\t\tcertificate ??\n\t\t\t\t(await this.certificateFromConfirmations({\n\t\t\t\t\tconfirmations,\n\t\t\t\t\tblobId,\n\t\t\t\t\tdeletable,\n\t\t\t\t\tblobObjectId,\n\t\t\t\t}));\n\n\t\t\tconst walrusPackageId = await this.#getWalrusPackageId();\n\n\t\t\ttx.add(\n\t\t\t\tcertifyBlob({\n\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\targuments: {\n\t\t\t\t\t\tself: this.#packageConfig.systemObjectId,\n\t\t\t\t\t\tblob: blobObjectId,\n\t\t\t\t\t\tsignature: tx.pure.vector('u8', combinedSignature.signature),\n\t\t\t\t\t\tsignersBitmap: tx.pure.vector(\n\t\t\t\t\t\t\t'u8',\n\t\t\t\t\t\t\tsignersToBitmap(combinedSignature.signers, systemState.committee.members.length),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tmessage: tx.pure.vector('u8', combinedSignature.serializedMessage),\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t);\n\t\t};\n\t}\n\n\t/**\n\t * Create a transaction that certifies a blob\n\t *\n\t * @example\n\t * ```ts\n\t * const tx = client.certifyBlobTransaction({ blobId, blobObjectId, confirmations });\n\t * ```\n\t */\n\tcertifyBlobTransaction({\n\t\ttransaction = new Transaction(),\n\t\t...options\n\t}: CertifyBlobOptions & {\n\t\ttransaction?: Transaction;\n\t}) {\n\t\ttransaction.add(this.certifyBlob(options));\n\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Execute a transaction that certifies a blob\n\t *\n\t * @example\n\t * ```ts\n\t * const { digest } = await client.executeCertifyBlobTransaction({ blobId, blobObjectId, confirmations, signer });\n\t * ```\n\t */\n\tasync executeCertifyBlobTransaction({\n\t\tsigner,\n\t\t...options\n\t}: CertifyBlobOptions & {\n\t\ttransaction?: Transaction;\n\t\tsigner: Signer;\n\t}) {\n\t\tconst transaction = this.certifyBlobTransaction(options);\n\n\t\tconst { digest } = await this.#executeTransaction(transaction, signer, 'certify blob');\n\n\t\treturn { digest };\n\t}\n\n\t/**\n\t * Delete a blob in a transaction\n\t *\n\t * @example\n\t * ```ts\n\t * const storage = await client.deleteBlob({ blobObjectId });\n\t * tx.transferObjects([storage], owner);\n\t * ```\n\t */\n\tdeleteBlob({ blobObjectId }: DeleteBlobOptions) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst walrusPackageId = await this.#getWalrusPackageId();\n\t\t\tconst storage = tx.add(\n\t\t\t\tdeleteBlob({\n\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\targuments: {\n\t\t\t\t\t\tself: this.#packageConfig.systemObjectId,\n\t\t\t\t\t\tblob: blobObjectId,\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\treturn storage;\n\t\t};\n\t}\n\n\t/**\n\t * Create a transaction that deletes a blob\n\t *\n\t * @example\n\t * ```ts\n\t * const tx = client.deleteBlobTransaction({ blobObjectId, owner });\n\t * ```\n\t */\n\tdeleteBlobTransaction({\n\t\towner,\n\t\tblobObjectId,\n\t\ttransaction = new Transaction(),\n\t}: DeleteBlobOptions & {\n\t\ttransaction?: Transaction;\n\t\t/** Address the storage resource should be returned to */\n\t\towner: string;\n\t}) {\n\t\tconst storage = transaction.add(this.deleteBlob({ blobObjectId }));\n\t\ttransaction.transferObjects([storage], owner);\n\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Execute a transaction that deletes a blob\n\t *\n\t * @example\n\t * ```ts\n\t * const { digest } = await client.executeDeleteBlobTransaction({ blobObjectId, signer });\n\t * ```\n\t */\n\tasync executeDeleteBlobTransaction({\n\t\tsigner,\n\t\ttransaction = new Transaction(),\n\t\tblobObjectId,\n\t}: DeleteBlobOptions & { signer: Signer; transaction?: Transaction }) {\n\t\tconst { digest } = await this.#executeTransaction(\n\t\t\tthis.deleteBlobTransaction({\n\t\t\t\tblobObjectId,\n\t\t\t\ttransaction,\n\t\t\t\towner: transaction.getData().sender ?? signer.toSuiAddress(),\n\t\t\t}),\n\t\t\tsigner,\n\t\t\t'delete blob',\n\t\t);\n\n\t\treturn { digest };\n\t}\n\n\t/**\n\t * Extend a blob in a transaction\n\t *\n\t * @example\n\t * ```ts\n\t * const tx = client.extendBlobTransaction({ blobObjectId, epochs });\n\t * ```\n\t */\n\textendBlob({ blobObjectId, epochs, endEpoch, walCoin }: ExtendBlobOptions) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst blob = await this.#objectLoader.load(blobObjectId, Blob);\n\t\t\tconst numEpochs = typeof epochs === 'number' ? epochs : endEpoch - blob.storage.end_epoch;\n\n\t\t\tif (numEpochs <= 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst { storageCost } = await this.#storageCostFromEncodedSize(\n\t\t\t\tNumber(blob.storage.storage_size),\n\t\t\t\tnumEpochs,\n\t\t\t);\n\t\t\tconst walrusPackageId = await this.#getWalrusPackageId();\n\n\t\t\treturn tx.add(\n\t\t\t\tthis.#withWal(storageCost, walCoin ?? null, async (coin, tx) => {\n\t\t\t\t\ttx.add(\n\t\t\t\t\t\textendBlob({\n\t\t\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\t\tself: this.#packageConfig.systemObjectId,\n\t\t\t\t\t\t\t\tblob: blobObjectId,\n\t\t\t\t\t\t\t\textendedEpochs: numEpochs,\n\t\t\t\t\t\t\t\tpayment: coin,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}),\n\t\t\t);\n\t\t};\n\t}\n\n\t/**\n\t * Create a transaction that extends a blob\n\t *\n\t * @example\n\t * ```ts\n\t * const tx = client.extendBlobTransaction({ blobObjectId, epochs });\n\t * ```\n\t */\n\tasync extendBlobTransaction({\n\t\ttransaction = new Transaction(),\n\t\t...options\n\t}: ExtendBlobOptions & { transaction?: Transaction }) {\n\t\ttransaction.add(this.extendBlob(options));\n\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Execute a transaction that extends a blob\n\t *\n\t * @example\n\t * ```ts\n\t * const { digest } = await client.executeExtendBlobTransaction({ blobObjectId, signer });\n\t * ```\n\t */\n\tasync executeExtendBlobTransaction({\n\t\tsigner,\n\t\t...options\n\t}: ExtendBlobOptions & { signer: Signer; transaction?: Transaction }) {\n\t\tconst { digest } = await this.#executeTransaction(\n\t\t\tawait this.extendBlobTransaction(options),\n\t\t\tsigner,\n\t\t\t'extend blob',\n\t\t);\n\n\t\treturn { digest };\n\t}\n\n\tasync readBlobAttributes({\n\t\tblobObjectId,\n\t}: {\n\t\tblobObjectId: string;\n\t}): Promise<Record<string, string> | null> {\n\t\tconst response = await this.#suiClient.core.getDynamicField({\n\t\t\tparentId: blobObjectId,\n\t\t\tname: {\n\t\t\t\ttype: 'vector<u8>',\n\t\t\t\tbcs: bcs.string().serialize('metadata').toBytes(),\n\t\t\t},\n\t\t});\n\n\t\tconst parsedMetadata = metadata.Metadata.parse(response.dynamicField.value.bcs);\n\n\t\treturn Object.fromEntries(\n\t\t\tparsedMetadata.metadata.contents.map(({ key, value }) => [key, value]),\n\t\t);\n\t}\n\n\t#writeBlobAttributesForRef({\n\t\tattributes,\n\t\texistingAttributes,\n\t\tblob,\n\t}: {\n\t\tattributes: Record<string, string | null>;\n\t\texistingAttributes: Record<string, string> | null;\n\t\tblob: TransactionObjectArgument;\n\t}) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst walrusPackageId = await this.#getWalrusPackageId();\n\n\t\t\tif (!existingAttributes) {\n\t\t\t\ttx.add(\n\t\t\t\t\taddMetadata({\n\t\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\tself: blob,\n\t\t\t\t\t\t\tmetadata: metadata._new({\n\t\t\t\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tObject.keys(attributes).forEach((key) => {\n\t\t\t\tconst value = attributes[key];\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\tif (existingAttributes && key in existingAttributes) {\n\t\t\t\t\t\ttx.add(\n\t\t\t\t\t\t\tremoveMetadataPair({\n\t\t\t\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\t\t\tself: blob,\n\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttx.add(\n\t\t\t\t\t\tinsertOrUpdateMetadataPair({\n\t\t\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\t\tself: blob,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t}\n\n\t/**\n\t * Write attributes to a blob\n\t *\n\t * If attributes already exists, their previous values will be overwritten\n\t * If an attribute is set to `null`, it will be removed from the blob\n\t *\n\t * @example\n\t * ```ts\n\t * tx.add(client.writeBlobAttributes({ blobObjectId, attributes: { key: 'value', keyToRemove: null } }));\n\t * ```\n\t */\n\twriteBlobAttributes({ blobObject, blobObjectId, attributes }: WriteBlobAttributesOptions) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst existingAttributes = blobObjectId\n\t\t\t\t? await this.readBlobAttributes({ blobObjectId })\n\t\t\t\t: null;\n\t\t\tconst blob = blobObject ?? tx.object(blobObjectId);\n\n\t\t\ttx.add(\n\t\t\t\tthis.#writeBlobAttributesForRef({\n\t\t\t\t\tattributes,\n\t\t\t\t\texistingAttributes,\n\t\t\t\t\tblob,\n\t\t\t\t}),\n\t\t\t);\n\t\t};\n\t}\n\n\t/**\n\t * Create a transaction that writes attributes to a blob\n\t *\n\t * If attributes already exists, their previous values will be overwritten\n\t * If an attribute is set to `null`, it will be removed from the blob\n\t *\n\t * @example\n\t * ```ts\n\t * const tx = client.writeBlobAttributesTransaction({ blobObjectId, attributes: { key: 'value', keyToRemove: null } });\n\t * ```\n\t */\n\tasync writeBlobAttributesTransaction({\n\t\ttransaction = new Transaction(),\n\t\t...options\n\t}: WriteBlobAttributesOptions & { transaction?: Transaction }) {\n\t\ttransaction.add(await this.writeBlobAttributes(options));\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Execute a transaction that writes attributes to a blob\n\t *\n\t * If attributes already exists, their previous values will be overwritten\n\t * If an attribute is set to `null`, it will be removed from the blob\n\t *\n\t * @example\n\t * ```ts\n\t * const { digest } = await client.executeWriteBlobAttributesTransaction({ blobObjectId, signer });\n\t * ```\n\t */\n\tasync executeWriteBlobAttributesTransaction({\n\t\tsigner,\n\t\t...options\n\t}: WriteBlobAttributesOptions & { signer: Signer; transaction?: Transaction }) {\n\t\tconst { digest } = await this.#executeTransaction(\n\t\t\tawait this.writeBlobAttributesTransaction(options),\n\t\t\tsigner,\n\t\t\t'write blob attributes',\n\t\t);\n\t\treturn { digest };\n\t}\n\n\t/**\n\t * Write a sliver to a storage node\n\t *\n\t * @example\n\t * ```ts\n\t * const res = await client.writeSliver({ blobId, sliverPairIndex, sliverType, sliver });\n\t * ```\n\t */\n\tasync writeSliver({ blobId, sliverPairIndex, sliverType, sliver, signal }: WriteSliverOptions) {\n\t\tconst systemState = await this.systemState();\n\t\tconst committee = await this.#getActiveCommittee();\n\n\t\tconst shardIndex = toShardIndex(sliverPairIndex, blobId, systemState.committee.n_shards);\n\t\tconst node = await this.#getNodeByShardIndex(committee, shardIndex);\n\n\t\treturn this.#storageNodeClient.storeSliver(\n\t\t\t{ blobId, sliverPairIndex, sliverType, sliver },\n\t\t\t{ nodeUrl: node.networkUrl, signal },\n\t\t);\n\t}\n\n\t/**\n\t * Write metadata to a storage node\n\t *\n\t * @example\n\t * ```ts\n\t * const res = await client.writeMetadataToNode({ nodeIndex, blobId, metadata });\n\t * ```\n\t */\n\tasync writeMetadataToNode({ nodeIndex, blobId, metadata, signal }: WriteMetadataOptions) {\n\t\tconst committee = await this.#getActiveCommittee();\n\t\tconst node = committee.nodes[nodeIndex];\n\n\t\treturn retry(\n\t\t\t() =>\n\t\t\t\tthis.#storageNodeClient.storeBlobMetadata(\n\t\t\t\t\t{ blobId, metadata },\n\t\t\t\t\t{ nodeUrl: node.networkUrl, signal },\n\t\t\t\t),\n\t\t\t{\n\t\t\t\tcount: 3,\n\t\t\t\tdelay: 1000,\n\t\t\t\tcondition: (error) => error instanceof BlobNotRegisteredError,\n\t\t\t},\n\t\t);\n\t}\n\n\t/**\n\t * Get a storage confirmation from a storage node\n\t *\n\t * @example\n\t * ```ts\n\t * const confirmation = await client.getStorageConfirmationFromNode({ nodeIndex, blobId, deletable, objectId });\n\t * ```\n\t */\n\tasync getStorageConfirmationFromNode({\n\t\tnodeIndex,\n\t\tblobId,\n\t\tdeletable,\n\t\tobjectId,\n\t\tsignal,\n\t}: GetStorageConfirmationOptions) {\n\t\tconst committee = await this.#getActiveCommittee();\n\t\tconst node = committee.nodes[nodeIndex];\n\n\t\tconst result = deletable\n\t\t\t? await this.#storageNodeClient.getDeletableBlobConfirmation(\n\t\t\t\t\t{ blobId, objectId },\n\t\t\t\t\t{ nodeUrl: node.networkUrl, signal },\n\t\t\t\t)\n\t\t\t: await this.#storageNodeClient.getPermanentBlobConfirmation(\n\t\t\t\t\t{ blobId },\n\t\t\t\t\t{ nodeUrl: node.networkUrl, signal },\n\t\t\t\t);\n\n\t\treturn result?.success?.data?.signed ?? null;\n\t}\n\n\t/**\n\t * Encode a blob into slivers for each node\n\t *\n\t * @example\n\t * ```ts\n\t * const { blobId, metadata, sliversByNode, rootHash } = await client.encodeBlob(blob);\n\t * ```\n\t */\n\tasync encodeBlob(blob: Uint8Array) {\n\t\tconst systemState = await this.systemState();\n\t\tconst committee = await this.#getActiveCommittee();\n\n\t\tconst numShards = systemState.committee.n_shards;\n\t\tconst bindings = await this.#wasmBindings();\n\t\tconst { blobId, metadata, primarySlivers, secondarySlivers, rootHash } = bindings.encodeBlob(\n\t\t\tnumShards,\n\t\t\tblob,\n\t\t);\n\n\t\tconst sliversByNodeMap = new Map<number, SliversForNode>();\n\n\t\t// Process each sliver pair (already BCS-encoded)\n\t\tfor (let sliverPairIndex = 0; sliverPairIndex < primarySlivers.length; sliverPairIndex++) {\n\t\t\tconst primarySliver = primarySlivers[sliverPairIndex];\n\t\t\tconst secondarySliver = secondarySlivers[sliverPairIndex];\n\n\t\t\tconst shardIndex = toShardIndex(sliverPairIndex, blobId, numShards);\n\t\t\tconst node = await this.#getNodeByShardIndex(committee, shardIndex);\n\n\t\t\tif (!sliversByNodeMap.has(node.nodeIndex)) {\n\t\t\t\tsliversByNodeMap.set(node.nodeIndex, { primary: [], secondary: [] });\n\t\t\t}\n\n\t\t\tsliversByNodeMap.get(node.nodeIndex)!.primary.push({\n\t\t\t\tsliverIndex: sliverPairIndex,\n\t\t\t\tsliverPairIndex,\n\t\t\t\tshardIndex,\n\t\t\t\tsliver: primarySliver,\n\t\t\t});\n\n\t\t\tsliversByNodeMap.get(node.nodeIndex)!.secondary.push({\n\t\t\t\tsliverIndex: sliverPairIndex,\n\t\t\t\tsliverPairIndex,\n\t\t\t\tshardIndex,\n\t\t\t\tsliver: secondarySliver,\n\t\t\t});\n\t\t}\n\n\t\tconst sliversByNode = new Array<SliversForNode>();\n\n\t\tfor (let i = 0; i < systemState.committee.members.length; i++) {\n\t\t\tsliversByNode.push(sliversByNodeMap.get(i) ?? { primary: [], secondary: [] });\n\t\t}\n\n\t\treturn { blobId, metadata, rootHash, sliversByNode };\n\t}\n\n\t/**\n\t * Write slivers to a storage node\n\t *\n\t * @example\n\t * ```ts\n\t * await client.writeSliversToNode({ blobId, slivers, signal });\n\t * ```\n\t */\n\tasync writeSliversToNode({ blobId, slivers, signal }: WriteSliversToNodeOptions) {\n\t\tconst controller = new AbortController();\n\t\tconst combinedSignal = signal\n\t\t\t? AbortSignal.any([controller.signal, signal])\n\t\t\t: controller.signal;\n\n\t\tconst primarySliverWrites = slivers.primary.map(({ sliverPairIndex, sliver }) => {\n\t\t\treturn this.writeSliver({\n\t\t\t\tblobId,\n\t\t\t\tsliverPairIndex,\n\t\t\t\tsliverType: 'primary',\n\t\t\t\tsliver,\n\t\t\t\tsignal: combinedSignal,\n\t\t\t});\n\t\t});\n\n\t\tconst secondarySliverWrites = slivers.secondary.map(({ sliverPairIndex, sliver }) => {\n\t\t\treturn this.writeSliver({\n\t\t\t\tblobId,\n\t\t\t\tsliverPairIndex,\n\t\t\t\tsliverType: 'secondary',\n\t\t\t\tsliver,\n\t\t\t\tsignal: combinedSignal,\n\t\t\t});\n\t\t});\n\n\t\tawait Promise.all([...primarySliverWrites, ...secondarySliverWrites]).catch((error) => {\n\t\t\tcontroller.abort(error);\n\t\t\tthrow error;\n\t\t});\n\t}\n\n\t/**\n\t * Write a blob to all storage nodes\n\t *\n\t * @example\n\t * ```ts\n\t * await client.writeEncodedBlobToNodes({ blob, deletable, epochs, signer });\n\t * ```\n\t */\n\tasync writeEncodedBlobToNodes({\n\t\tblobId,\n\t\tmetadata,\n\t\tsliversByNode,\n\t\tsignal,\n\t\t...options\n\t}: WriteEncodedBlobToNodesOptions) {\n\t\tconst systemState = await this.systemState();\n\t\tconst committee = await this.#getActiveCommittee();\n\n\t\tconst controller = new AbortController();\n\t\tlet failures = 0;\n\n\t\tconst confirmations = await Promise.all(\n\t\t\tsliversByNode.map((slivers, nodeIndex) => {\n\t\t\t\treturn this.writeEncodedBlobToNode({\n\t\t\t\t\tblobId,\n\t\t\t\t\tnodeIndex,\n\t\t\t\t\tmetadata,\n\t\t\t\t\tslivers,\n\t\t\t\t\tsignal: signal ? AbortSignal.any([controller.signal, signal]) : controller.signal,\n\t\t\t\t\t...options,\n\t\t\t\t}).catch(() => {\n\t\t\t\t\tfailures += committee.nodes[nodeIndex].shardIndices.length;\n\n\t\t\t\t\tif (isAboveValidity(failures, systemState.committee.n_shards)) {\n\t\t\t\t\t\tconst error = new NotEnoughBlobConfirmationsError(\n\t\t\t\t\t\t\t`Too many failures while writing blob ${blobId} to nodes`,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tcontroller.abort(error);\n\t\t\t\t\t\tthrow error;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t});\n\t\t\t}),\n\t\t);\n\n\t\treturn confirmations;\n\t}\n\n\t/**\n\t * Writes a blob to to an upload relay\n\t *\n\t * @example\n\t * ```ts\n\t * await client.writeBlobToUploadRelay({ blob, deletable, epochs, signer });\n\t * ```\n\t */\n\tasync writeBlobToUploadRelay(options: WriteBlobToUploadRelayOptions): Promise<{\n\t\tblobId: string;\n\t\tcertificate: ProtocolMessageCertificate;\n\t}> {\n\t\tif (!this.#uploadRelayClient) {\n\t\t\tthrow new WalrusClientError('Upload relay not configured');\n\t\t}\n\n\t\treturn this.#uploadRelayClient.writeBlob({\n\t\t\t...options,\n\t\t\trequiresTip: !!this.#uploadRelayConfig?.sendTip,\n\t\t});\n\t}\n\n\t/**\n\t * Write encoded blob to a storage node\n\t *\n\t * @example\n\t * ```ts\n\t * const res = await client.writeEncodedBlobToNode({ nodeIndex, blobId, metadata, slivers });\n\t * ```\n\t */\n\tasync writeEncodedBlobToNode({\n\t\tnodeIndex,\n\t\tblobId,\n\t\tmetadata,\n\t\tslivers,\n\t\tsignal,\n\t\t...options\n\t}: WriteEncodedBlobOptions) {\n\t\tawait this.writeMetadataToNode({\n\t\t\tnodeIndex,\n\t\t\tblobId,\n\t\t\tmetadata,\n\t\t\tsignal,\n\t\t});\n\n\t\tawait this.writeSliversToNode({ blobId, slivers, signal, nodeIndex });\n\n\t\treturn this.getStorageConfirmationFromNode({\n\t\t\tnodeIndex,\n\t\t\tblobId,\n\t\t\t...options,\n\t\t});\n\t}\n\n\t/**\n\t * Write a blob to all storage nodes\n\t *\n\t * @example\n\t * ```ts\n\t * const { blobId, blobObject } = await client.writeBlob({ blob, deletable, epochs, signer });\n\t * ```\n\t */\n\tasync writeBlob({\n\t\tblob,\n\t\tdeletable,\n\t\tepochs,\n\t\tsigner,\n\t\tsignal,\n\t\towner,\n\t\tattributes,\n\t}: WriteBlobOptions) {\n\t\tif (!this.#uploadRelayConfig) {\n\t\t\tconst encoded = await this.encodeBlob(blob);\n\t\t\tconst blobId = encoded.blobId;\n\t\t\tconst { sliversByNode, metadata, rootHash } = encoded;\n\n\t\t\tconst suiBlobObject = await this.executeRegisterBlobTransaction({\n\t\t\t\tsigner,\n\t\t\t\tsize: blob.length,\n\t\t\t\tepochs,\n\t\t\t\tblobId,\n\t\t\t\trootHash,\n\t\t\t\tdeletable,\n\t\t\t\towner: owner ?? signer.toSuiAddress(),\n\t\t\t\tattributes,\n\t\t\t});\n\n\t\t\tconst blobObjectId = suiBlobObject.blob.id;\n\n\t\t\tconst confirmations = await this.writeEncodedBlobToNodes({\n\t\t\t\tblobId,\n\t\t\t\tmetadata,\n\t\t\t\tsliversByNode,\n\t\t\t\tdeletable,\n\t\t\t\tobjectId: blobObjectId,\n\t\t\t\tsignal,\n\t\t\t});\n\n\t\t\tawait this.executeCertifyBlobTransaction({\n\t\t\t\tsigner,\n\t\t\t\tblobId,\n\t\t\t\tblobObjectId,\n\t\t\t\tconfirmations,\n\t\t\t\tdeletable,\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tblobId,\n\t\t\t\tblobObject: await this.#objectLoader.load(blobObjectId, Blob),\n\t\t\t};\n\t\t} else {\n\t\t\tconst metadata = await this.computeBlobMetadata({\n\t\t\t\tbytes: blob,\n\t\t\t});\n\t\t\tconst blobId = metadata.blobId;\n\n\t\t\tconst transaction = new Transaction();\n\n\t\t\ttransaction.add(\n\t\t\t\tthis.sendUploadRelayTip({\n\t\t\t\t\tsize: blob.length,\n\t\t\t\t\tblobDigest: metadata.blobDigest,\n\t\t\t\t\tnonce: metadata.nonce,\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\tconst registerResult = await this.executeRegisterBlobTransaction({\n\t\t\t\tsigner,\n\t\t\t\ttransaction,\n\t\t\t\tsize: blob.length,\n\t\t\t\tepochs,\n\t\t\t\tblobId: metadata.blobId,\n\t\t\t\trootHash: metadata.rootHash,\n\t\t\t\tdeletable,\n\t\t\t\towner: owner ?? signer.toSuiAddress(),\n\t\t\t\tattributes,\n\t\t\t});\n\n\t\t\tawait this.#suiClient.core.waitForTransaction({\n\t\t\t\tdigest: registerResult.digest,\n\t\t\t});\n\n\t\t\tconst result = await this.writeBlobToUploadRelay({\n\t\t\t\tblobId,\n\t\t\t\tblob,\n\t\t\t\tnonce: metadata.nonce,\n\t\t\t\ttxDigest: registerResult.digest,\n\t\t\t\tsignal,\n\t\t\t\tdeletable,\n\t\t\t\tblobObjectId: registerResult.blob.id,\n\t\t\t\tencodingType: metadata.metadata.encodingType as EncodingType,\n\t\t\t});\n\n\t\t\tconst certificate = result.certificate;\n\t\t\tconst blobObjectId = registerResult.blob.id;\n\n\t\t\tawait this.executeCertifyBlobTransaction({\n\t\t\t\tsigner,\n\t\t\t\tblobId,\n\t\t\t\tblobObjectId,\n\t\t\t\tcertificate,\n\t\t\t\tdeletable,\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tblobId,\n\t\t\t\tblobObject: await this.#objectLoader.load(blobObjectId, Blob),\n\t\t\t};\n\t\t}\n\t}\n\n\tasync writeQuilt({ blobs, ...options }: WriteQuiltOptions) {\n\t\tconst encoded = await this.encodeQuilt({ blobs });\n\t\tconst result = await this.writeBlob({\n\t\t\t...options,\n\t\t\tblob: encoded.quilt,\n\t\t\tattributes: {\n\t\t\t\t_walrusBlobType: 'quilt',\n\t\t\t\t...options.attributes,\n\t\t\t},\n\t\t});\n\n\t\treturn {\n\t\t\t...result,\n\t\t\tindex: {\n\t\t\t\t...encoded.index,\n\t\t\t\tpatches: encoded.index.patches.map((patch) => ({\n\t\t\t\t\t...patch,\n\t\t\t\t\tpatchId: encodeQuiltPatchId({\n\t\t\t\t\t\tquiltId: result.blobId,\n\t\t\t\t\t\tpatchId: {\n\t\t\t\t\t\t\tversion: 1,\n\t\t\t\t\t\t\tstartIndex: patch.startIndex,\n\t\t\t\t\t\t\tendIndex: patch.endIndex,\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t})),\n\t\t\t},\n\t\t};\n\t}\n\n\tasync encodeQuilt({\n\t\tblobs,\n\t}: {\n\t\tblobs: {\n\t\t\tcontents: Uint8Array;\n\t\t\tidentifier: string;\n\t\t\ttags?: Record<string, string>;\n\t\t}[];\n\t}) {\n\t\tconst systemState = await this.systemState();\n\t\tconst encoded = encodeQuilt({\n\t\t\tblobs,\n\t\t\tnumShards: systemState.committee.n_shards,\n\t\t});\n\n\t\treturn encoded;\n\t}\n\n\tasync #executeTransaction(transaction: Transaction, signer: Signer, action: string) {\n\t\ttransaction.setSenderIfNotSet(signer.toSuiAddress());\n\n\t\tconst result = await signer.signAndExecuteTransaction({\n\t\t\ttransaction,\n\t\t\tclient: this.#suiClient,\n\t\t});\n\n\t\tif (result.FailedTransaction) {\n\t\t\tthrow new WalrusClientError(\n\t\t\t\t`Failed to ${action} (${result.FailedTransaction.digest}): ${result.FailedTransaction.status.error?.message}`,\n\t\t\t);\n\t\t}\n\n\t\tconst { digest, effects } = result.Transaction;\n\n\t\tawait this.#suiClient.core.waitForTransaction({\n\t\t\tdigest,\n\t\t});\n\n\t\treturn { digest, effects };\n\t}\n\n\tasync #getCommittee(committee: InferBcsType<typeof Committee>) {\n\t\tconst stakingPool = await this.#stakingPool(committee);\n\t\tconst shardIndicesByNodeId = getShardIndicesByNodeId(committee);\n\n\t\tconst byShardIndex = new Map<number, StorageNode>();\n\t\tconst nodes = stakingPool.map(({ node_info }, nodeIndex) => {\n\t\t\tconst shardIndices = shardIndicesByNodeId.get(node_info.node_id) ?? [];\n\t\t\tconst node: StorageNode = {\n\t\t\t\tid: node_info.node_id,\n\t\t\t\tinfo: node_info,\n\t\t\t\tnetworkUrl: `https://${node_info.network_address}`,\n\t\t\t\tshardIndices,\n\t\t\t\tnodeIndex,\n\t\t\t};\n\n\t\t\tfor (const shardIndex of shardIndices) {\n\t\t\t\tbyShardIndex.set(shardIndex, node);\n\t\t\t}\n\n\t\t\treturn node;\n\t\t});\n\n\t\treturn {\n\t\t\tbyShardIndex,\n\t\t\tnodes,\n\t\t};\n\t}\n\n\t#getActiveCommittee() {\n\t\treturn this.#cache.read(['getActiveCommittee'], async () => {\n\t\t\tconst stakingState = await this.stakingState();\n\t\t\treturn this.#getCommittee(stakingState.committee);\n\t\t});\n\t}\n\n\tasync #stakingPool(committee: InferBcsType<typeof Committee>) {\n\t\tconst nodeIds = committee[0].contents.map((node) => node.key);\n\t\treturn this.#objectLoader.loadManyOrThrow(nodeIds, StakingPool);\n\t}\n\n\tasync #getNodeByShardIndex(committeeInfo: CommitteeInfo, index: number) {\n\t\tconst node = committeeInfo.byShardIndex.get(index);\n\t\tif (!node) {\n\t\t\tthrow new WalrusClientError(`Node for shard index ${index} not found`);\n\t\t}\n\t\treturn node;\n\t}\n\n\t/**\n\t * Reset cached data in the client\n\t *\n\t * @example\n\t * ```ts\n\t * client.reset();\n\t * ```\n\t */\n\treset() {\n\t\tthis.#objectLoader.clearAll();\n\t\tthis.#cache.clear();\n\t}\n\n\t#retryOnPossibleEpochChange<T extends (...args: any[]) => Promise<any>>(fn: T): T {\n\t\treturn (async (...args: Parameters<T>) => {\n\t\t\ttry {\n\t\t\t\treturn await fn.apply(this, args);\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof RetryableWalrusClientError) {\n\t\t\t\t\tthis.reset();\n\t\t\t\t\treturn await fn.apply(this, args);\n\t\t\t\t}\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}) as T;\n\t}\n\n\tasync getBlob({ blobId }: { blobId: string }) {\n\t\treturn new WalrusBlob({\n\t\t\treader: new BlobReader({\n\t\t\t\tclient: this,\n\t\t\t\tblobId,\n\t\t\t\tnumShards: (await this.systemState()).committee.n_shards,\n\t\t\t}),\n\t\t\tclient: this,\n\t\t});\n\t}\n\n\tasync getFiles({ ids }: { ids: string[] }) {\n\t\tconst readersByBlobId = new Map<string, BlobReader>();\n\t\tconst quiltReadersByBlobId = new Map<string, QuiltReader>();\n\t\tconst parsedIds = ids.map((id) => parseWalrusId(id));\n\t\tconst numShards = (await this.systemState()).committee.n_shards;\n\n\t\tfor (const id of parsedIds) {\n\t\t\tconst blobId = id.kind === 'blob' ? id.id : id.id.quiltId;\n\t\t\tif (!readersByBlobId.has(blobId)) {\n\t\t\t\treadersByBlobId.set(\n\t\t\t\t\tblobId,\n\t\t\t\t\tnew BlobReader({\n\t\t\t\t\t\tclient: this,\n\t\t\t\t\t\tblobId,\n\t\t\t\t\t\tnumShards,\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (id.kind === 'quiltPatch') {\n\t\t\t\tif (!quiltReadersByBlobId.has(blobId)) {\n\t\t\t\t\tquiltReadersByBlobId.set(\n\t\t\t\t\t\tblobId,\n\t\t\t\t\t\tnew QuiltReader({\n\t\t\t\t\t\t\tblob: readersByBlobId.get(blobId)!,\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn parsedIds.map((id) => {\n\t\t\tif (id.kind === 'blob') {\n\t\t\t\treturn new WalrusFile({\n\t\t\t\t\treader: readersByBlobId.get(id.id)!,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new WalrusFile({\n\t\t\t\treader: new QuiltFileReader({\n\t\t\t\t\tquilt: quiltReadersByBlobId.get(id.id.quiltId)!,\n\t\t\t\t\tsliverIndex: id.id.patchId.startIndex,\n\t\t\t\t}),\n\t\t\t});\n\t\t});\n\t}\n\n\tasync writeFiles({ files, ...options }: WriteFilesOptions) {\n\t\tconst { blobId, index, blobObject } = await this.writeQuilt({\n\t\t\t...options,\n\t\t\tblobs: await Promise.all(\n\t\t\t\tfiles.map(async (file, i) => ({\n\t\t\t\t\tcontents: await file.bytes(),\n\t\t\t\t\tidentifier: (await file.getIdentifier()) ?? `file-${i}`,\n\t\t\t\t\ttags: (await file.getTags()) ?? {},\n\t\t\t\t})),\n\t\t\t),\n\t\t});\n\n\t\treturn index.patches.map((patch) => ({\n\t\t\tid: patch.patchId,\n\t\t\tblobId,\n\t\t\tblobObject,\n\t\t}));\n\t}\n\n\twriteFilesFlow({ files }: WriteFilesFlowOptions): WriteFilesFlow {\n\t\tconst encode = async () => {\n\t\t\tconst { quilt, index } = await this.encodeQuilt({\n\t\t\t\tblobs: await Promise.all(\n\t\t\t\t\tfiles.map(async (file, i) => ({\n\t\t\t\t\t\tcontents: await file.bytes(),\n\t\t\t\t\t\tidentifier: (await file.getIdentifier()) ?? `file-${i}`,\n\t\t\t\t\t\ttags: (await file.getTags()) ?? {},\n\t\t\t\t\t})),\n\t\t\t\t),\n\t\t\t});\n\t\t\tconst metadata = this.#uploadRelayClient\n\t\t\t\t? await this.computeBlobMetadata({\n\t\t\t\t\t\tbytes: quilt,\n\t\t\t\t\t})\n\t\t\t\t: await this.encodeBlob(quilt);\n\n\t\t\treturn {\n\t\t\t\tmetadata,\n\t\t\t\tsize: quilt.length,\n\t\t\t\tdata: this.#uploadRelayClient ? quilt : undefined,\n\t\t\t\tindex,\n\t\t\t};\n\t\t};\n\n\t\tconst register = (\n\t\t\t{ data, metadata, index, size }: Awaited<ReturnType<typeof encode>>,\n\t\t\t{ epochs, deletable, owner, attributes }: WriteFilesFlowRegisterOptions,\n\t\t) => {\n\t\t\tconst transaction = new Transaction();\n\t\t\ttransaction.setSenderIfNotSet(owner);\n\n\t\t\tif (this.#uploadRelayClient) {\n\t\t\t\tconst meta = metadata as Awaited<ReturnType<typeof this.computeBlobMetadata>>;\n\t\t\t\ttransaction.add(\n\t\t\t\t\tthis.sendUploadRelayTip({\n\t\t\t\t\t\tsize,\n\t\t\t\t\t\tblobDigest: meta.blobDigest,\n\t\t\t\t\t\tnonce: meta.nonce,\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\ttransaction.transferObjects(\n\t\t\t\t[\n\t\t\t\t\tthis.registerBlob({\n\t\t\t\t\t\tsize,\n\t\t\t\t\t\tepochs,\n\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\trootHash: metadata.rootHash,\n\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\tattributes: {\n\t\t\t\t\t\t\t_walrusBlobType: 'quilt',\n\t\t\t\t\t\t\t...attributes,\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t],\n\t\t\t\towner,\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tregisterTransaction: transaction,\n\t\t\t\tindex,\n\t\t\t\tdata,\n\t\t\t\tmetadata,\n\t\t\t\tdeletable,\n\t\t\t};\n\t\t};\n\n\t\tconst upload = async (\n\t\t\t{ index, data, metadata, deletable }: Awaited<ReturnType<typeof register>>,\n\t\t\t{ digest }: WriteFilesFlowUploadOptions,\n\t\t) => {\n\t\t\tconst blobObject = await this.#getCreatedBlob(digest);\n\n\t\t\tif (this.#uploadRelayClient) {\n\t\t\t\tconst meta = metadata as Awaited<ReturnType<typeof this.computeBlobMetadata>>;\n\t\t\t\treturn {\n\t\t\t\t\tindex,\n\t\t\t\t\tblobObject,\n\t\t\t\t\tmetadata,\n\t\t\t\t\tdeletable,\n\t\t\t\t\tcertificate: (\n\t\t\t\t\t\tawait this.writeBlobToUploadRelay({\n\t\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\t\tblob: data!,\n\t\t\t\t\t\t\tnonce: meta.nonce,\n\t\t\t\t\t\t\ttxDigest: digest,\n\t\t\t\t\t\t\tblobObjectId: blobObject.id,\n\t\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\t\tencodingType: meta.metadata.encodingType as EncodingType,\n\t\t\t\t\t\t})\n\t\t\t\t\t).certificate,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst meta = metadata as Awaited<ReturnType<typeof this.encodeBlob>>;\n\n\t\t\treturn {\n\t\t\t\tindex,\n\t\t\t\tblobObject,\n\t\t\t\tmetadata,\n\t\t\t\tdeletable,\n\t\t\t\tconfirmations: await this.writeEncodedBlobToNodes({\n\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\tobjectId: blobObject.id,\n\t\t\t\t\tmetadata: meta.metadata,\n\t\t\t\t\tsliversByNode: meta.sliversByNode,\n\t\t\t\t\tdeletable,\n\t\t\t\t}),\n\t\t\t};\n\t\t};\n\n\t\tconst certify = ({\n\t\t\tindex,\n\t\t\tmetadata,\n\t\t\tconfirmations,\n\t\t\tcertificate,\n\t\t\tblobObject,\n\t\t\tdeletable,\n\t\t}: Awaited<ReturnType<typeof upload>>) => {\n\t\t\treturn {\n\t\t\t\tindex,\n\t\t\t\tblobObject,\n\t\t\t\tmetadata,\n\t\t\t\ttransaction: confirmations\n\t\t\t\t\t? this.certifyBlobTransaction({\n\t\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\t\tblobObjectId: blobObject.id,\n\t\t\t\t\t\t\tconfirmations,\n\t\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\t})\n\t\t\t\t\t: this.certifyBlobTransaction({\n\t\t\t\t\t\t\tcertificate,\n\t\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\t\tblobObjectId: blobObject.id,\n\t\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\t}),\n\t\t\t};\n\t\t};\n\n\t\tasync function listFiles({ index, blobObject, metadata }: Awaited<ReturnType<typeof certify>>) {\n\t\t\treturn index.patches.map((patch) => ({\n\t\t\t\tid: encodeQuiltPatchId({\n\t\t\t\t\tquiltId: metadata.blobId,\n\t\t\t\t\tpatchId: {\n\t\t\t\t\t\tversion: 1,\n\t\t\t\t\t\tstartIndex: patch.startIndex,\n\t\t\t\t\t\tendIndex: patch.endIndex,\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t\tblobId: metadata.blobId,\n\t\t\t\tblobObject,\n\t\t\t}));\n\t\t}\n\n\t\tconst stepResults: {\n\t\t\tencode?: Awaited<ReturnType<typeof encode>>;\n\t\t\tregister?: Awaited<ReturnType<typeof register>>;\n\t\t\tupload?: Awaited<ReturnType<typeof upload>>;\n\t\t\tcertify?: Awaited<ReturnType<typeof certify>>;\n\t\t\tlistFiles?: never;\n\t\t} = {};\n\n\t\tfunction getResults<T extends keyof typeof stepResults>(\n\t\t\tstep: T,\n\t\t\tcurrent: keyof typeof stepResults,\n\t\t): NonNullable<(typeof stepResults)[T]> {\n\t\t\tif (!stepResults[step]) {\n\t\t\t\tthrow new Error(`${step} must be executed before calling ${current}`);\n\t\t\t}\n\t\t\treturn stepResults[step];\n\t\t}\n\n\t\treturn {\n\t\t\tencode: async () => {\n\t\t\t\tif (!stepResults.encode) {\n\t\t\t\t\tstepResults.encode = await encode();\n\t\t\t\t}\n\t\t\t},\n\t\t\tregister: (options: WriteFilesFlowRegisterOptions) => {\n\t\t\t\tstepResults.register = register(getResults('encode', 'register'), options);\n\t\t\t\treturn stepResults.register.registerTransaction;\n\t\t\t},\n\t\t\tupload: async (options: WriteFilesFlowUploadOptions) => {\n\t\t\t\tstepResults.upload = await upload(getResults('register', 'upload'), options);\n\t\t\t},\n\t\t\tcertify: () => {\n\t\t\t\tstepResults.certify = certify(getResults('upload', 'certify'));\n\t\t\t\treturn stepResults.certify.transaction;\n\t\t\t},\n\t\t\tlistFiles: async () => {\n\t\t\t\treturn listFiles(getResults('certify', 'listFiles'));\n\t\t\t},\n\t\t};\n\t}\n\n\twriteBlobFlow({ blob }: WriteBlobFlowOptions): WriteBlobFlow {\n\t\tconst encode = async () => {\n\t\t\tconst metadata = this.#uploadRelayClient\n\t\t\t\t? await this.computeBlobMetadata({\n\t\t\t\t\t\tbytes: blob,\n\t\t\t\t\t})\n\t\t\t\t: await this.encodeBlob(blob);\n\n\t\t\treturn {\n\t\t\t\tmetadata,\n\t\t\t\tsize: blob.length,\n\t\t\t\tdata: this.#uploadRelayClient ? blob : undefined,\n\t\t\t};\n\t\t};\n\n\t\tconst register = (\n\t\t\t{ data, metadata, size }: Awaited<ReturnType<typeof encode>>,\n\t\t\t{ epochs, deletable, owner, attributes }: WriteBlobFlowRegisterOptions,\n\t\t) => {\n\t\t\tconst transaction = new Transaction();\n\t\t\ttransaction.setSenderIfNotSet(owner);\n\n\t\t\tif (this.#uploadRelayClient) {\n\t\t\t\tconst meta = metadata as Awaited<ReturnType<typeof this.computeBlobMetadata>>;\n\t\t\t\ttransaction.add(\n\t\t\t\t\tthis.sendUploadRelayTip({\n\t\t\t\t\t\tsize,\n\t\t\t\t\t\tblobDigest: meta.blobDigest,\n\t\t\t\t\t\tnonce: meta.nonce,\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\ttransaction.transferObjects(\n\t\t\t\t[\n\t\t\t\t\tthis.registerBlob({\n\t\t\t\t\t\tsize,\n\t\t\t\t\t\tepochs,\n\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\trootHash: metadata.rootHash,\n\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\tattributes,\n\t\t\t\t\t}),\n\t\t\t\t],\n\t\t\t\towner,\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tregisterTransaction: transaction,\n\t\t\t\tdata,\n\t\t\t\tmetadata,\n\t\t\t\tdeletable,\n\t\t\t};\n\t\t};\n\n\t\tconst upload = async (\n\t\t\t{ data, metadata, deletable }: Awaited<ReturnType<typeof register>>,\n\t\t\t{ digest }: WriteBlobFlowUploadOptions,\n\t\t) => {\n\t\t\tconst blobObject = await this.#getCreatedBlob(digest);\n\n\t\t\tif (this.#uploadRelayClient) {\n\t\t\t\tconst meta = metadata as Awaited<ReturnType<typeof this.computeBlobMetadata>>;\n\t\t\t\treturn {\n\t\t\t\t\tblobObject,\n\t\t\t\t\tmetadata,\n\t\t\t\t\tdeletable,\n\t\t\t\t\tcertificate: (\n\t\t\t\t\t\tawait this.writeBlobToUploadRelay({\n\t\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\t\tblob: data!,\n\t\t\t\t\t\t\tnonce: meta.nonce,\n\t\t\t\t\t\t\ttxDigest: digest,\n\t\t\t\t\t\t\tblobObjectId: blobObject.id,\n\t\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\t\tencodingType: meta.metadata.encodingType as EncodingType,\n\t\t\t\t\t\t})\n\t\t\t\t\t).certificate,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst meta = metadata as Awaited<ReturnType<typeof this.encodeBlob>>;\n\n\t\t\treturn {\n\t\t\t\tblobObject,\n\t\t\t\tmetadata,\n\t\t\t\tdeletable,\n\t\t\t\tconfirmations: await this.writeEncodedBlobToNodes({\n\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\tobjectId: blobObject.id,\n\t\t\t\t\tmetadata: meta.metadata,\n\t\t\t\t\tsliversByNode: meta.sliversByNode,\n\t\t\t\t\tdeletable,\n\t\t\t\t}),\n\t\t\t};\n\t\t};\n\n\t\tconst certify = ({\n\t\t\tmetadata,\n\t\t\tconfirmations,\n\t\t\tcertificate,\n\t\t\tblobObject,\n\t\t\tdeletable,\n\t\t}: Awaited<ReturnType<typeof upload>>) => {\n\t\t\treturn {\n\t\t\t\tblobObject,\n\t\t\t\tmetadata,\n\t\t\t\ttransaction: confirmations\n\t\t\t\t\t? this.certifyBlobTransaction({\n\t\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\t\tblobObjectId: blobObject.id,\n\t\t\t\t\t\t\tconfirmations,\n\t\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\t})\n\t\t\t\t\t: this.certifyBlobTransaction({\n\t\t\t\t\t\t\tcertificate,\n\t\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\t\tblobObjectId: blobObject.id,\n\t\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\t}),\n\t\t\t};\n\t\t};\n\n\t\tasync function getBlob({ blobObject, metadata }: Awaited<ReturnType<typeof certify>>) {\n\t\t\treturn {\n\t\t\t\tblobId: metadata.blobId,\n\t\t\t\tblobObject,\n\t\t\t};\n\t\t}\n\n\t\tconst stepResults: {\n\t\t\tencode?: Awaited<ReturnType<typeof encode>>;\n\t\t\tregister?: Awaited<ReturnType<typeof register>>;\n\t\t\tupload?: Awaited<ReturnType<typeof upload>>;\n\t\t\tcertify?: Awaited<ReturnType<typeof certify>>;\n\t\t\tgetBlob?: never;\n\t\t} = {};\n\n\t\tfunction getResults<T extends keyof typeof stepResults>(\n\t\t\tstep: T,\n\t\t\tcurrent: keyof typeof stepResults,\n\t\t): NonNullable<(typeof stepResults)[T]> {\n\t\t\tif (!stepResults[step]) {\n\t\t\t\tthrow new Error(`${step} must be executed before calling ${current}`);\n\t\t\t}\n\t\t\treturn stepResults[step];\n\t\t}\n\n\t\treturn {\n\t\t\tencode: async () => {\n\t\t\t\tif (!stepResults.encode) {\n\t\t\t\t\tstepResults.encode = await encode();\n\t\t\t\t}\n\t\t\t},\n\t\t\tregister: (options: WriteBlobFlowRegisterOptions) => {\n\t\t\t\tstepResults.register = register(getResults('encode', 'register'), options);\n\t\t\t\treturn stepResults.register.registerTransaction;\n\t\t\t},\n\t\t\tupload: async (options: WriteBlobFlowUploadOptions) => {\n\t\t\t\tstepResults.upload = await upload(getResults('register', 'upload'), options);\n\t\t\t},\n\t\t\tcertify: () => {\n\t\t\t\tstepResults.certify = certify(getResults('upload', 'certify'));\n\t\t\t\treturn stepResults.certify.transaction;\n\t\t\t},\n\t\t\tgetBlob: async () => {\n\t\t\t\treturn getBlob(getResults('certify', 'getBlob'));\n\t\t\t},\n\t\t};\n\t}\n}\n"],"mappings":"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"}