//#region src/error.ts
var WalrusClientError = class extends Error {};
var RetryableWalrusClientError = class extends WalrusClientError {};
/** Thrown when the client could not retrieve the status of a blob from any storage node. */
var NoBlobStatusReceivedError = class extends WalrusClientError {};
/** Thrown when the client could not retrieve a verified blob status for the blob. */
var NoVerifiedBlobStatusReceivedError = class extends WalrusClientError {};
/** Thrown when the client could not retrieve blob metadata from any storage node. */
var NoBlobMetadataReceivedError = class extends RetryableWalrusClientError {};
/** Thrown when the client could not retrieve enough slivers to reconstruct the blob. */
var NotEnoughSliversReceivedError = class extends RetryableWalrusClientError {};
/** Thrown when the client could not write enough slivers to upload the blob. */
var NotEnoughBlobConfirmationsError = class extends RetryableWalrusClientError {};
/** Thrown when the client is currently behind the current epoch. */
var BehindCurrentEpochError = class extends RetryableWalrusClientError {};
/** Thrown when a blob is not certified or determined to not exist. */
var BlobNotCertifiedError = class extends RetryableWalrusClientError {};
/** Thrown when a blob was determined to be incorrectly encoded. */
var InconsistentBlobError = class extends WalrusClientError {};
/** Thrown when blob is blocked by a quorum of storage nodes. */
var BlobBlockedError = class extends Error {};

//#endregion
export { BehindCurrentEpochError, BlobBlockedError, BlobNotCertifiedError, InconsistentBlobError, NoBlobMetadataReceivedError, NoBlobStatusReceivedError, NoVerifiedBlobStatusReceivedError, NotEnoughBlobConfirmationsError, NotEnoughSliversReceivedError, RetryableWalrusClientError, WalrusClientError };
//# sourceMappingURL=error.mjs.map